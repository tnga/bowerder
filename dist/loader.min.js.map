{"version":3,"sources":["loader.js"],"names":["bower","components","Object","window","console","warn","dir","devMode","loadingCount","total","callbacks","packagesTree","cdn","usage","rawgit","browser","loaded","regTag","undefined","loaderTag","waitingCB","waitingImport","error","occured","fromBrowser","fromBowerder","xhrGet","path","isAsync","callback","String","Boolean","Function","xhr","XMLHttpRequest","overrideMimeType","ActiveXObject","e1","e2","message","open","send","onreadystatechange","response","readyState","status","text","responseText","statusText","packageIndex","pkgName","i","name","checkCallback","counter","main","length","forEach","ready","push","cbIndex","attachPackageCB","node","Element","attachEvent","toString","indexOf","isOpera","addEventListener","from","parseTagType","targetFile","tag","type","fext","slice","Math","max","lastIndexOf","Infinity","test","rel","addPackage","pkgCaller","fetchPackage","reponse","pkgInfos","JSON","parse","repository_url","replace","latest_release_number","getPackageConfig","jsonURL","Number","pkgConfig","loadPackageConfig","checkReadyToImport","async","splice","pkgDeps","getOwnPropertyNames","j","pkgScriptTags","pkgLinkTags","isAlreadyLoaded","opera","domLoaderTags","devLinkTag","devScriptTag","getTag","pkg","document","querySelector","head","call","getElementsByTagName","concat","getAttribute","index","createElement","setAttribute","src","href","insertBefore","appendChild","log","isAlreadyOk","pkgConfigURL","rawgitURL","domScriptTags","onload","pkgInfo","onerror"],"mappings":"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","file":"loader.min.js","sourcesContent":["/* the bower components loader for browsers\n ________________________________________________________________________________________\n *\n * Easly Import your components or libraries installed via bower to your project.\n * \n * @license MIT\n * @author  [Tindo N. Arsel](mailto:devtnga@gmail.com)\n*/\n\n// manage possible conflict with loader namespace definition.\nif (typeof bower !== 'undefined' && !(bower.components instanceof Object)) {\n\n   console.warn('Seem like `bower` namespace is use for another purpose. Taking risk of an overwrite ...');\n   window.bower = bower = {};\n   console.warn('Forcing `bower` namespace initialization ... done.');\n\n} else if (typeof bower === 'undefined') {\n\n   window.bower = {};\n}\n\n/* importing package is an interresting hack when we have to avoid duplicate import and manage dependencies.\n * the method here is to have a registry where we will add package's configuration in particular order (function of dependency or not).\n * package's configuration is an object build from `bower.json` assciated file.\n * dependencies will always be imported before package of which depends; this influences how order is done in packages's configuration registry.\n * package have to have a unique occurrence on the registry; this assure that we will not have duplicate component's import.\n * that particular registry is the *dependencies package's tree registry*.\n * there will be also a main registry which is the *local packages's registry*, that will content all project's components's configurations installed via bower.\n * there will be therefore a provided command line tools (`bowerder`) that will help developer to generate the considered *local packages's registry* for a target project.\n * if the loader can't use any associated *local packages's registry* to import packages, it will try to use Ajax API to resolve the operation.\n * bower components directory have to be provided to loader so that it can know where to find packages main files. (this can be done through the global `dir` property)\n * however setting a `data-bowerreg` attribute to bowerder's script tag will be sufficient to it for determination of some needed like `bower components directory`.\n * \n * with each import instruction, can be associated a callback function.\n * considered callback is executed when associated package's importation is fully done.\n * package's importation is fully done when all it main files and it dependencies main files (if defined) are loaded *in the DOM*.\n * a callback take an object as argument with the following properties:\n * `occured` : a boolean which inform if the associated package's importation was fully done or not (if an error occured or not);\n * `from` : a string which inform about the place where the error occured, possible value are \"browser\" or \"bowerder\";\n *    if the value is \"bowerder\" it's maybe an internal/connection error when loading package configuration (bower.json),\n *    if the value is \"browser\" it's maybe a 404/connection error on loading main files *in the DOM*;\n *    therefore, console is the place to see what really happen.\n * that object is usefull to check if there isn't an error (conditions are good) for some instructions.\n * in case of contionnal or timed importation, if a package is already fully imported or have already adressed a full loading process, the associated callback will be immediatly executed.\n * this is to introduce the fact that many callbacks can be associated to a package's importation via multiple `import's` instructions.\n * that said there will be a registry where we can acces to any package's associated callbacks, via the package's name.\n * \n * for some globals tasks, global callbacks can be managed through the special bowerder \"reserved\" package's named `#bowerder`.\n * global callback take an object as argument with the following properties:\n * `occured` : a boolean which inform if all package's importation was fully done or not (if an error occured or not);\n * `fromBrowser` : an array which inform about packages where error occured and if it was from \"browser\" loading operations;\n * `fromBowerder` : an array which inform about packages where error occured and if it was from \"bowerder\" loading operations;\n *    therefore, console is the place to see what really happen.\n *    \n * to better manage some stuff, the loader can set extras porperties through the `browser` object, which will be itself a property of the package's configuration object. \n*/\n\nbower.dir = './bower_components';      // bower base directory\nbower.devMode = false;      // bower base directory\nbower.loadingCount = 0;   // number of package that are in loading process\nbower.total = 0;          // total number of packages that must to be loaded\nbower.callbacks = {};     // packages's callback functions registry \nbower.packagesTree = [];  // packages's configuration registry\n\nbower.cdn = {\n   usage: false, // allow bower to use code deliver network (using online bower registry)\n   rawgit: {}      // for rawgit cdn url of availables packages to load\n}\n\nbower.browser = {          // these properties will help in some case for bowerder global processing.\n   loaded: false,\n   regTag: undefined,    // reference to *local packages's registry* script tag\n   loaderTag: undefined, // reference to bowerder's script tag\n   waitingCB: [],         // index of callbacks's to be execute after full packages's importation \"in the DOM\" \n   waitingImport: [],     // for package that will wait for *local packages's registry* state, before to be imported\n   error: {occured: false, fromBrowser: [], fromBowerder: []},\n};\n\n\n/**\n * get the text reponse through an ajax request from a given path\n * @param   {string}   path     path where to get file's content\n * @param   {boolean}  isAsync  enable request asynchrone or not\n * @param   {function} callback the function to execute after the end of request process. take the returned object as argument \n * @returns {object}   content the answer informations with this properties {error: boolean, status: number, statusText: string, text: string}\n */\nbower.xhrGet = function (path, isAsync, callback) {\n\n   if (typeof path !== 'string' && !(path instanceof String)) {\n\n      console.error('bowerder: path must be give as a string');\n      return null;\n   }\n\n   isAsync = (typeof isAsync === 'boolean' || isAsync instanceof Boolean) ? isAsync : true;\n   callback = (typeof callback === 'function' || callback instanceof Function) ? callback : undefined;\n\n   var xhr = undefined;\n\n   if (window.XMLHttpRequest) {\n\n      xhr = new XMLHttpRequest(); // For Chrome, Firefox, Opera and others...\n\n      if (xhr.overrideMimeType)\n         xhr.overrideMimeType('text/xml'); // Avoid Safari’s bug\n   }\n   else if (window.ActiveXObject) {\n      // For Internet Explorer\n      try {\n         xhr = new ActiveXObject('Msxml2.XMLHTTP');  \n      } catch (e1) {\n         try {\n            xhr = new ActiveXObject('Microsoft.XMLHTTP');  \n         } catch (e2) {\n            console.warn( e1.message );\n            console.warn( e2.message );\n         }\n      }\n   }\n\n   if (!(xhr instanceof Object)) {\n\n      console.error(\"bowerder: Can’t init Ajax functionalities. Maybe it’s your browser version ?\");\n      return null;\n   }\n\n   // on soumet les champs de connexion à la page de traitement approprié pour vérification\n   xhr.open('GET', path, true);\n   // xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n   // Si la requêtte s'est exécutée sans erreur on recupère le resultat du traitement\n   xhr.send();\n\n   xhr.onreadystatechange = function() {\n\n      var response = {};\n      response.error = false;\n\n      if(xhr.readyState == 4 && xhr.status == 200) {\n\n         response.status = xhr.status;\n         response.text = xhr.responseText;\n\n         if (callback) callback( response );\n\n         return response;\n      } \n      else if (xhr.readyState == 4 && xhr.status != 200) {\n\n         response.status = xhr.status;\n         response.statusText = xhr.statusText;\n         response.error = true;\n         console.error('bowerder: Ajax request error (status: '+ xhr.status +'), try to check your connection. ');\n\n         if (callback) callback( response );\n\n         return response;\n      }\n   }  \n};\n\n/**\n * helpfull to determine if a package is in the packages's configuration registry\n * @param   {string} pkgName the name of the package\n * @returns {number} index of the first occurrence of the given package. -1 if it's isn't in the registry.\n */\nbower.packageIndex = function (pkgName) {\n\n   if (typeof pkgName !== 'string' && !(pkgName instanceof String)) {\n\n      console.error('bowerder:packageIndex: argument must be a string' );\n   }\n   else {\n\n      for (i in bower.packagesTree) {\n\n         if (bower.packagesTree[i].name === pkgName) return i;\n      }\n   }\n\n   return -1;\n};\n\n/**\n * helpfull to get a package's configuration from the registry\n * @param   {string} pkgName the name of the package\n * @returns {object} the first occurrence of the given package. undefined if it's isn't in the registry.\n */\nbower.package = function (pkgName) {\n\n   return bower.packagesTree[ bower.packageIndex( pkgName ) ];\n};\n\n/**\n * check the correct moment to execute callbacks associated to a package and do it.\n * @param {string} pkgName the name of a package\n */\nbower.checkCallback = function (pkgName) {\n\n   /* the hack here is to be sure that all associated main files of considered package are loaded in the browser.\n    * this is checked with a counter which content the number of main files that was loaded (event if the loading fail with browser loading process).\n    * therefore the package is fully imported when the counter is equal to total of the package's main files.\n    * callback is executed only if the package is fully imported.\n   */\n   if (!bower.package( pkgName ).browser.loaded) bower.package( pkgName ).browser.counter++;\n\n   if (bower.package( pkgName ).browser.counter === bower.package( pkgName ).browser.main.length) {\n\n      bower.package( pkgName ).browser.loaded = true; \n\n      if (bower.callbacks[ pkgName ]) {\n\n         bower.callbacks[ pkgName ].forEach( function (callback) {\n\n            callback( bower.package( pkgName ).browser.error );\n         });\n      }\n\n      //will check if all packages are fully imported for global callbacks's executions\n      bower.ready(); \n   }\n}\n\n/**\n * usefull to run callbacks after full packages's importation \"in the DOM\".\n * @param {function} callback function to execute. If empty, the function will try to run waiting callbacks.\n */\nbower.ready = function (callback) {\n\n   if (callback) {\n\n      if (typeof callback !== 'function' && !(callback instanceof Function)) {\n\n         console.warn('bowerder:ready: argument must be a function' );\n      }\n      else {\n\n         if (!bower.callbacks['#bowerder']) bower.callbacks['#bowerder'] = [];\n\n         bower.callbacks['#bowerder'].push( callback );\n\n         /* with current ready's process, callback which is added to the callbacks's registry have the last index for the associated package,\n          * that index is keeped and will be use to access to that callback if necessary in certains conditions\n         */\n         bower.browser.waitingCB.push( bower.callbacks['#bowerder'].length - 1 );\n      }\n   }\n\n   if (bower.packagesTree.length > 0) bower.browser.loaded = true;\n\n   for (var i=0; i<bower.packagesTree.length; i++) {\n\n      if (!bower.packagesTree[i].browser.loaded) {\n\n         bower.browser.loaded = false;\n         break;\n      }\n   }\n\n   if (bower.browser.loaded) {\n\n      bower.browser.waitingCB.forEach( function (cbIndex) {\n\n         bower.callbacks['#bowerder'][cbIndex]( bower.browser.error );\n      });\n   }\n};  \n\n/**\n * attach considered package's callbacks to it main files browser `load` event\n * @param   {Element}  node    element to attach callbacks on it `load` event\n * @param   {string}   pkgName package's name to use associated callbacks\n*/\nbower.attachPackageCB = function (node, pkgName) {\n\n   if (!(node instanceof Element)) {\n\n      console.warn('bowerder:attachPackageCB: argument must be an Element');\n      return null;\n   }\n\n   // Set up load listener. Test attachEvent first because IE9 has\n   // a subtle issue in its addEventListener and script onload firings\n   // that do not match the behavior of all other browsers with\n   // addEventListener support, which fire the onload event for a\n   // script right after the script execution. See:\n   // https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution\n   // UNFORTUNATELY Opera implements attachEvent but does not follow the script\n   // script execution mode.\n   if (node.attachEvent &&\n       // Check if node.attachEvent is artificially added by custom script or\n       // natively supported by browser\n       // read https://github.com/requirejs/requirejs/issues/187\n       // if we can NOT find [native code] then it must NOT natively supported.\n       // in IE8, node.attachEvent does not have toString()\n       // Note the test for \"[native code\" with no closing brace, see:\n       // https://github.com/requirejs/requirejs/issues/273\n       !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&\n       !isOpera) {\n      // Probably IE. IE (at least 6-8) do not fire\n      // script onload right after executing the script, so\n      // we cannot tie the anonymous define call to a name.\n      // However, IE reports the script as being in 'interactive'\n      // readyState at the time of the define call.\n\n      node.attachEvent('onreadystatechange', function () { bower.checkCallback( pkgName ); });\n      // It would be great to add an error handler here to catch\n      // 404s in IE9+. However, onreadystatechange will fire before\n      // the error handler, so that does not help. If addEventListener\n      // is used, then IE will fire error before load, but we cannot\n      // use that pathway given the connect.microsoft.com issue\n      // mentioned above about not doing the 'script execute,\n      // then fire the script load event listener before execute\n      // next script' that other browsers do.\n      // Best hope: IE10 fixes the issues,\n      // and then destroys all installs of IE 6-9.\n      // node.attachEvent('onerror', context.onScriptError);\n   } else {\n\n      node.addEventListener('load', function () { bower.checkCallback( pkgName ); }, false);\n      node.addEventListener('error', function () { \n\n         bower.package( pkgName ).browser.error = {occured: true, from: 'browser'};\n         bower.browser.error.occured = true;\n         bower.browser.error.fromBrowser.push( pkgName );\n\n         bower.checkCallback( pkgName ); \n      }, false );\n   }\n}\n\n/**\n * helpfull to determine which html tag have to be used to import a component in the DOM\n * @param   {string} targetFile component's file to include\n * @returns {object} an object that contains informations about html tag to use\n */\nbower.parseTagType = function (targetFile) {\n\n   if (typeof targetFile !== 'string' && !(targetFile instanceof String)) {\n\n      console.error('bowerder:parseTagType: argument must be a string' );\n      targetFile = \"\";\n   }\n\n   var tag = {name: 'unknow', type: 'unknow'};\n   // get the target file extension\n   tag.fext = targetFile.slice((Math.max(0, targetFile.lastIndexOf('.')) || Infinity) + 1);\n\n   if (tag.fext === 'js') { // it's a js like file\n\n      tag.name = 'script';\n      tag.type = 'text/javascript';        \n   }\n   if (tag.fext === 'css' || tag.fext ==='scss' || tag.fext ==='sass' || tag.fext ==='less') { // it's a css like\n\n      tag.name = 'link';\n      tag.type = 'text/css';\n\n      if (/\\.css$/.test( targetFile )) tag.rel = 'stylesheet';\n      else tag.rel = 'stylesheet/'+ tag.fext;            \n   }\n   if (tag.fext === 'txt') { // it's a plain text like file\n\n      tag.name = 'link';\n      tag.type = 'text/plain';        \n      tag.rel = 'alternate';\n      // @TODO set the tag.title with the name of the targetFile (regex must be usefull here)\n   }\n\n   return tag;\n};\n\n/**\n * organize packages's tree dependencies, process their importation \"in the DOM\" with asssociated callback if available\n * @param   {string}   pkgName   package's name\n * @param   {string}   pkgCaller package's of package which depends of first (argument) given package. usefull for dependencies management.\n * @param   {number}   cbIndex   index of current associated callback in callbacks's registry (if given)\n */\nbower.addPackage = function (pkgName, pkgCaller, cbIndex) {\n\n   if (typeof pkgName !== 'string' && !(pkgName instanceof String)) {\n\n      console.error(\"bowerder:addPackage: package's name must be a string\");\n      return null;\n   }\n   if (pkgCaller && (typeof pkgCaller !== 'string') && !(pkgCaller instanceof String)) console.warn(\"bowerder:addPackage: package caller's name must be a string\");\n   if (cbIndex && (typeof cbIndex !== 'number') && !(cbIndex instanceof Number)) console.warn(\"bowerder:addPackage: callback index must be a number\");\n\n   var isAlreadyOk = false;\n\n   /* check if package to load is already present in the registry.\n    * if it's a dependency, check if it's present in the registry before package of which depends.\n    * if so, nothing will be done, else the adding operation to the registry will be process.\n   */\n   if (bower.package( pkgName )) {\n\n      isAlreadyOk = true;\n\n      // if the package is already fully loaded *in the DOM*, the current associated callback is executed.\n      if (cbIndex && bower.package( pkgName ).browser.loaded && bower.callbacks[ pkgName ]) {\n\n         bower.callbacks[ pkgName ][cbIndex]( bower.package( pkgName ).browser.error );\n      }\n\n      if (pkgCaller && (bower.packageIndex( pkgCaller ) != -1) ) {\n         /* major browsers load and execute script included by another script asynchronously.\n          * the problem here is that, package which have dependencies have to be execute after them.\n          * therefore, for these package, it's primordial to load them synchronously.\n         */\n         bower.package( pkgName ).browser.async = false;\n         bower.package( pkgCaller ).browser.async = false;\n\n         if (bower.packageIndex( pkgCaller ) < bower.packageIndex( pkgName )) isAlreadyOk = false;\n      }\n   }\n   \n   if (!isAlreadyOk) { // process the adding operation to the registry.\n\n      bower.loadingCount++;\n      bower.total++;\n\n      if ((bower.components instanceof Object) && bower.components[ pkgName ]) {\n        \n         var pkgConfig = bower.components[ pkgName ];\n         /* for reason due to size some properties in `bower.json` have been deleted with provided local registry (using bowerder on command line).\n          * `name` is one of them, and the reason of it was removed was to avoid duplication since as once can see, package's configuration is accessible with package's name.\n          * this is valable for `bower.components` (local registry), but not for `bower.packagesTree` (import registry), which need that `name` property to be set.\n         */\n         pkgConfig.name = pkgName;\n\n         loadPackageConfig( pkgConfig );\n         \n         if (bower.cdn.usage) {\n            \n            fetchPackage( pkgName, function () {\n               \n               checkReadyToImport(); \n            });\n         }\n         else checkReadyToImport();\n      }\n      else {\n\n         if ((bower.components instanceof Object) && !bower.components[ pkgName ]) {\n\n            console.warn(\"bowerder:addPackage: can't found `\"+ pkgName +\"` in project's local registry; will try to import package through Ajax API.\");\n         }\n\n         var pkgConfigURL = bower.dir +'/'+ pkgName +'/bower.json';\n         \n         if (bower.cdn.usage) {\n            \n            fetchPackage( pkgName, function (rawgitURL) {\n                \n               if (rawgitURL) pkgConfigURL = rawgitURL + '/bower.json';\n               \n               getPackageConfig( pkgConfigURL );\n            });\n         }\n         else getPackageConfig( pkgConfigURL );\n      }\n      \n      \n      /**\n       * search package from online bower registry and parse resulting informations that can help for loading process. \n       * @param {string}   pkgName  the name of a package\n       * @param {function} callback the function to execute after the end of request process. take the resulting rawgit url as argument \n       */\n      function fetchPackage( pkgName, callback) {\n                  \n         bower.xhrGet('https://libraries.io/api/bower/'+ pkgName, true, function (reponse) {\n\n            if (!reponse.error) {\n\n               var pkgInfos = JSON.parse( reponse.text ); \n               \n               if (pkgInfos instanceof Object) {\n\n                  if (/^https:\\/\\/github.com/i.test( pkgInfos.repository_url )) {\n\n                     //@TODO remove this test hack and only consider the else instruction when jquery's search will result to appropriate repository (https://github.com/jquery/jquery-dist)\n                     if (pkgName === 'jquery') {\n                        bower.cdn.rawgit[ pkgName ] = 'https://cdn.rawgit.com/'+ pkgInfos.repository_url.replace('https://github.com/', '') +'-dist' +'/'+ ((pkgInfos.latest_release_number) ? pkgInfos.latest_release_number : 'master');\n                     }\n                     else bower.cdn.rawgit[ pkgName ] = 'https://cdn.rawgit.com/'+ pkgInfos.repository_url.replace('https://github.com/', '') +'/'+ ((pkgInfos.latest_release_number) ? pkgInfos.latest_release_number : 'master');\n                  }\n                  else console.warn('bowerder:addPackage: can\\'t yet able to load `'+ pkgName +'` from '+ pkgInfos[i].repository_url +' repository.' );\n               }\n               else console.warn('bowerder:addPackage: invalid loaded meta-data of `'+ pkgName +'`.' );\n            }\n            else console.error('bowerder:addPackage: unable to find `'+ pkgName +'` from online registry.' );  \n            \n            if (callback) callback( bower.cdn.rawgit[ pkgName ] );\n         });\n      }\n      \n      /**\n       * locally get and parse a `bower.json` config file of a package\n       * @param {string} jsonURL url where to get the `bower.json` of a package\n       */\n      function getPackageConfig (jsonURL) {\n         \n         bower.xhrGet( jsonURL, true, function (reponse) {\n\n            if (reponse.error) {\n\n               console.error('bowerder:addPackage: unable to load `'+ pkgName +'` component.' );\n\n               /* considering that the package will not be imported and\n                * then will not be added to the packages's configuration registry,\n                * associated callback functions are executed with error from bowerder.\n               */\n               if ((typeof cbIndex === 'number' || cbIndex instanceof Number) && bower.callbacks[ pkgName ]) {\n\n                  bower.callbacks[ pkgName ][cbIndex]( {occured: true, from: 'bowerder'} );\n               } \n\n               bower.browser.error.occured = true;\n               bower.browser.error.fromBowerder.push( pkgName );                \n            }\n            else {\n\n               var pkgConfig = JSON.parse( reponse.text ); \n\n               if (pkgConfig instanceof Object) {\n\n                  delete pkgConfig['ignore'];\n                  delete pkgConfig['keywords'];\n                  delete pkgConfig['moduleType'];\n                  delete pkgConfig['resolutions'];\n\n                  loadPackageConfig( pkgConfig );\n               }\n               else {\n\n                  console.warn('bowerder:addPackage: unable to load `'+ pkgName +'` component.' );\n               }\n            } \n\n            checkReadyToImport();\n         });\n      }\n\n      /**\n       * register package's configuration with it dependencies (if defined) in the packages's tree registry.\n       * @param {object} pkgConfig package's configuration from it `bower.json`\n       * @private\n      */\n      function loadPackageConfig (pkgConfig) {\n\n         if (!(pkgConfig.browser instanceof Object)) pkgConfig.browser = {};\n         // by default,load and execute script asynchronously\n         pkgConfig.browser.async = true;\n         // by default, files to load from the package aren't yet imported\n         pkgConfig.browser.loaded = false;\n         // by default, set importation status to done without error  \n         pkgConfig.browser.error = {occured: false, from: undefined};\n         // init the number of imported file counter for the package\n         pkgConfig.browser.counter = 0;\n\n         /* minification is a way for developer to have for some files a better loading optimization. \n          * however, `bower.json` spec do not allow to use minified files as mains files for a component.\n          * developers use to set associated `main` property with sources or developments files.\n          * considering how web projects are now build, that pratice isn't advantageous for browsers.\n          * indeed, set an `index.scss` or an unminified `index.js` files *(depending of size)* as main file isn't good for browsers to digest.\n          * that why is now recommended to also set a `browser: {main: []}` properties for mains files that browsers can easly digest.\n          * minified files with sourcemaps are specialy welcome in that case.\n          * bowerder will use that properties to load component *in the DOM*; if they aren't set, it will use the `main` property. \n          * here is an example illustration for bowerder to well do it job:\n          * // bower.json\n          *    main: [\"dist/index.scss\", \"dist/index.coffee\"], // keep bower json spec\n          *    browser: {\n          *       main: [\"dist/index.min.css\", \"dist/index.min.js\"] // for browsers through bowerder\n          *    }\n          *    ... // others properties\n         */\n         if (!pkgConfig.browser.main) {\n\n            if (!pkgConfig.main) {\n\n               console.warn(\"bowerder:addPackage: there isn't main files indication for \"+ pkgName);\n               pkgConfig.main = [];\n            }\n\n            pkgConfig.browser.main = (typeof pkgConfig.main === 'string') ? [pkgConfig.main] : pkgConfig.main;\n         }\n\n         /* if `pkgCaller` is set, then current loading package adress by `pkgName` is a dependency.\n          * therefore, it have to be added before the `pkgCaller` in the packages's configuration registry.\n          * else it's just a package to add in the considered registry.\n         */\n         if (pkgCaller) {\n\n            // mark package to be synchronously loaded and executed\n            pkgConfig.browser.async = false;\n            bower.package( pkgCaller ).browser.async = false;\n\n            if (bower.packageIndex( pkgCaller ) != -1) {\n\n               bower.packagesTree.splice( bower.packageIndex( pkgCaller ), 0, pkgConfig);\n            }\n         }\n         else {\n\n            bower.packagesTree.push( pkgConfig );\n         }\n\n         // if the current loading package have dependencies, then also process their loading\n         if (pkgConfig['dependencies']) {\n\n            var pkgDeps = Object.getOwnPropertyNames( pkgConfig['dependencies'] );\n\n            pkgDeps.forEach( function (name) {\n\n               bower.addPackage( name, pkgConfig['name']);\n            });\n         }\n      }\n\n      /**\n       * make sure that loadings packages's configuration process are ok with good dependencies organization,\n       * and proceed to packages importation *in the DOM* with correct order and associated behavior (callback, ...).\n       * @private\n      */\n      function checkReadyToImport() {\n\n         bower.loadingCount--;\n\n         // when all the loading package process are finished, process their importation on the DOM.\n         if (bower.loadingCount === 0) {\n\n            /* if all loading package's configuration process have failed, \n             * directly run globals callbacks (if they are).\n             * this, considering the fact that error can be check from callback by using the `error` argument.\n            */\n            if (bower.packagesTree.length === 0) {\n\n               bower.browser.loaded = true;\n               bower.ready();\n            }\n            else {\n\n               // be sure to have unique package occurence in package's tree\n               for (var i=0; i < bower.packagesTree.length; i++) {\n\n                  for (var j=i+1; j < bower.packagesTree.length; j++) {\n\n                     if (bower.packagesTree[i].name === bower.packagesTree[j].name) {\n\n                        bower.packagesTree.splice( j, 1);\n                        bower.total--;\n\n                        j--;\n                     }\n                  }\n               }\n\n               var pkgScriptTags = [],\n                   pkgLinkTags = [],\n                   isAlreadyLoaded = false,\n                   // Oh the tragedy, detecting opera. See the usage of isOpera for reason.\n                   isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',\n                   loaderTag = undefined,\n                   domLoaderTags = undefined,\n                   devLinkTag = undefined,   // first custom link tag include by developer *in the document's <head>*\n                   devScriptTag = undefined, // first custom Script tag include by developer *in the document's <head>*\n                   getTag = undefined;       // supported tag\n\n               bower.packagesTree.forEach( function (pkg) {\n\n                  isAlreadyLoaded = false;\n                  /* before include a loader tag in the DOM, it's primordial to check if the associated file isn't already loaded in.\n                   * this assure to have an unique instance of a package in the DOM include by our `bower loader`.\n                  */\n                  if (document.querySelector) {\n                     // efficient : this is for all major browsers and IE>8\n                     if (document.head.querySelector('[data-bowerpkg =\"'+pkg.name+'\"]')) isAlreadyLoaded = true;\n                  }\n                  else { // alternative with more hack : this is specialy for IE<=8\n\n                     domLoaderTags = [].slice.call( document.head.getElementsByTagName('link') );\n                     domLoaderTags = domLoaderTags.concat( [].slice.call( document.head.getElementsByTagName('scrpit') ) );\n                     for (var j=0; j < domLoaderTags.length; j++) {\n\n                        if (domLoaderTags[j].getAttribute('data-bowerpkg') === pkg.name ) {\n\n                           isAlreadyLoaded = true;\n                           break;\n                        }\n                     }\n                  }\n\n                  if (!isAlreadyLoaded) {\n\n                     for (index in pkg.browser.main) {\n\n                        getTag = bower.parseTagType( pkg.browser.main[ index ] );\n\n                        if (getTag.name === 'script') { \n\n                           loaderTag = document.createElement('script');\n                           loaderTag.setAttribute('data-bowerpkg', pkg.name);\n                           loaderTag.type = getTag.type;\n                           loaderTag.async = pkg.browser.async;\n\n                           /* with time, for other script support, paid attention to `load` event issue for some file by browsers.\n                            * look at comments below for `link` tag hack for more details.\n                           */\n                           bower.attachPackageCB( loaderTag, pkg.name );\n\n                           if (bower.cdn.usage && bower.cdn.rawgit[ pkg.name ]) {\n                              \n                              loaderTag.src = bower.cdn.rawgit[ pkg.name ] +'/'+ pkg.browser.main[ index ];\n                           }\n                           else loaderTag.src = bower.dir +'/'+ pkg.name +'/'+ pkg.browser.main[ index ];\n\n                           pkgScriptTags.push( loaderTag );\n                        }\n                        if (getTag.name === 'link') {\n\n                           loaderTag = document.createElement('link');\n                           loaderTag.setAttribute('data-bowerpkg', pkg.name);\n                           loaderTag.rel = getTag.rel;\n                           loaderTag.type = getTag.type;\n\n                           /* browsers (as tested on firefox and chrome) seems to not execute event listeners \n                            * attached to `load` envent of some file (exception for css).\n                            * unless will find hack to resolve that, callbacks assignement will be directly checked\n                            * before considered files will have their path set to be included to the DOM.\n                           */\n                           if (getTag.fext !== \"css\") {\n\n                              console.warn(\"bowerder: can't attach callback to `onload` event of \"+ pkg.name +\"/\"+ pkg.browser.main[ index ]);\n                              bower.checkCallback( pkg.name );\n                           }\n                           else bower.attachPackageCB( loaderTag, pkg.name );\n\n                           if (bower.cdn.usage && bower.cdn.rawgit[ pkg.name ]) {\n\n                              loaderTag.href = bower.cdn.rawgit[ pkg.name ] +'/'+ pkg.browser.main[ index ];\n                           }\n                           else loaderTag.href = bower.dir +'/'+ pkg.name +'/'+ pkg.browser.main[ index ];\n\n                           pkgLinkTags.push( loaderTag );\n                        }  \n                        if (getTag.name === 'unknow') {\n\n                           // console.warn('bowerder: unable to load unsupported file: '+ bower.dir +'/'+ pkg.name +'/'+ pkg.browser.main[ index ]);\n                           // count the file for loading's fetching state \n                           bower.package( pkg.name ).browser.counter++;\n                        }                       \n                     }\n                  }\n               });\n\n               /* generally, developer use to include custom stylesheets or scripts,\n                * to overwrite library's properties or functions.\n                * this is done by including library first, before that custom hacks.\n                * therefore bowerder have to do the same to maintain that habit.\n                * loader can identify it imported packages with the `data-bowerpkg` attribute.\n                * it just to make sure to import them before non `data-bowerpkg` considered tag *in document <head>*.\n               */ \n               domLoaderTags = document.head.getElementsByTagName('link');\n               for (var i=0; i < domLoaderTags.length; i++) {\n\n                  if (!domLoaderTags[i].getAttribute('data-bowerpkg') && domLoaderTags[i].rel && (domLoaderTags[i].rel !== 'icon')) {\n\n                     devLinkTag = domLoaderTags[i];\n                     break;\n                  }\n               }\n               domLoaderTags = document.head.getElementsByTagName('script');\n               for (var i=0; i < domLoaderTags.length; i++) {\n\n                  if (!domLoaderTags[i].getAttribute('data-bowerpkg')) {\n\n                     devScriptTag = domLoaderTags[i];\n                     break;\n                  }\n               }\n\n               // Link tags importation process \"in the DOM\"\n               if (devLinkTag) {\n\n                  pkgLinkTags.forEach( function (loaderTag) {\n\n                     document.head.insertBefore( loaderTag, devLinkTag );\n                  });\n               }\n               else {\n\n                  pkgLinkTags.forEach( function (loaderTag) {\n\n                     document.head.appendChild( loaderTag );\n                  });\n               }\n\n               // Script tags importation process \"in the DOM\"\n               if (devScriptTag) {\n\n                  pkgScriptTags.forEach( function (loaderTag) {\n\n                     document.head.insertBefore( loaderTag, devScriptTag );\n                  });\n               }\n               else {\n\n                  pkgScriptTags.forEach( function (loaderTag) {\n\n                     document.head.appendChild( loaderTag );\n                  });\n               }\n\n               if (bower.devMode) console.log( bower.packagesTree );\n            }\n         }\n      }\n   }\n};\n\n\n/**\n * import packages \"in the DOM\" with their dependecies \n * @param   {string}   pkgName  package's name\n * @param   {function} callback function to run after full package's importation\n*/\nbower.import = function (pkgName, callback) {\n\n   if (typeof pkgName !== 'string' && !(pkgName instanceof String)) {\n\n      console.error('bowerder:import: argument must be a string' );\n      return null;\n   }\n\n   if (callback) {\n\n      if (typeof callback !== 'function' && !(callback instanceof Function)) {\n\n         console.warn('bowerder:import: argument must be a function' );\n      }\n      else {\n\n         if (!bower.callbacks[ pkgName ]) bower.callbacks[ pkgName ] = [];\n\n         bower.callbacks[ pkgName ].push( callback );\n\n         /* with current import's process, callback which is added to the callbacks's registry have the last index.\n          * that index is keeped and will be use to access to that callback if necessary in certains conditions.\n          * loader will be able to import package when the bower components's local registry state will be determinate.\n         */\n         if (!(bower.components instanceof Object) && bower.components !== null) {\n\n            bower.browser.waitingImport.push( {name: pkgName, cbIndex: (bower.callbacks[ pkgName ].length - 1)} );\n         }\n         else bower.addPackage( pkgName, null, (bower.callbacks[ pkgName ].length - 1) );\n      }\n   }\n   else {\n\n      if (!(bower.components instanceof Object) && bower.components !== null) {\n\n         bower.browser.waitingImport.push( {name: pkgName, cbIndex: undefined} );\n      }\n      else bower.addPackage( pkgName );\n   } \n\n};\n\n\n/* first execution zone\n------------------------*/\n/* developer can manually include the bower components's local registry *in the DOM*.\n * if not, the bowerder have to try to include it by itself for better performence for loading process.\n*/\nif (bower.components === undefined) {\n   /* loader script have to be include *in the DOM* with the `data-bowerreg` attribute setting.\n    * that attribute will help to know which tag have to be use to automate local packages's registry loading.\n   */\n   if (document.querySelector) {\n      // efficient : this is for all major browsers and IE>8\n      bower.browser.loaderTag = document.querySelector('script[data-bowerreg]');\n   }\n   else { // alternative with more hack : this is specialy for IE<=8\n\n      var domScriptTags = document.getElementsByTagName('scrpit');\n\n      for (var j=0; j < domScriptTags.length; j++) {\n\n         if (domScriptTags[j].getAttribute('data-bowerreg')) {\n\n            bower.browser.loaderTag = domScriptTags[j];\n            break;\n         }\n      }\n   }\n\n   if (bower.browser.loaderTag) {\n\n      // assuming that loader path will usually be `path-to-bowerdir/bowerder/dist/loader.js`\n      bower.dir = bower.browser.loaderTag.src;\n      for (var i=0; i<3; i++) bower.dir = bower.dir.slice(0, bower.dir.lastIndexOf('/') );\n\n      bower.browser.regTag = document.createElement('script');\n      bower.browser.regTag.onload = function () {\n\n         if (!(bower.components instanceof Object)) {\n\n            bower.components = null; // will allow not already run import's function call to skip waiting import step\n            console.warn('bowerder: local registry isn\\'t found, loader will try to import package through Ajax API.');\n         }\n\n         bower.browser.waitingImport.forEach( function (pkgInfo) {\n\n            bower.addPackage( pkgInfo.name, null, pkgInfo.cbIndex );\n         });\n         bower.browser.waitingImport = [];\n      };\n      bower.browser.regTag.onreadystatechange = bower.browser.regTag.onerror = bower.browser.regTag.onload;\n\n      bower.browser.regTag.setAttribute('data-bowerpkg', '#bowerder');\n      bower.browser.regTag.src = bower.dir +'/.bowerreg.js';\n\n      document.head.appendChild( bower.browser.regTag );\n   }\n   else {\n\n      bower.components = null; // will allow not already run import's function call to skip waiting import step\n      console.warn('bowerder: seems that local registry isn\\'t provided; if so, loader will try to import package through Ajax API.');\n   }\n}"],"sourceRoot":"/source/"}