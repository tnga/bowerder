{"version":3,"sources":["loader.js"],"names":["bower","components","Object","window","console","warn","dir","devMode","isRegStated","loadingCount","total","callbacks","packagesTree","cdn","usage","rawgit","browser","loaded","regState","regTag","undefined","loaderTag","waitingCB","waitingImport","error","occured","fromBrowser","fromBowerder","xhrGet","path","isAsync","callback","String","Boolean","Function","xhr","XMLHttpRequest","overrideMimeType","ActiveXObject","e1","e2","message","open","send","onreadystatechange","response","readyState","status","text","responseText","statusText","packageIndex","pkgName","i","name","checkCallback","counter","main","length","forEach","ready","push","cbi","attachPackageCB","node","Element","attachEvent","toString","indexOf","isOpera","addEventListener","from","parseTagType","targetFile","tag","type","fext","slice","Math","max","lastIndexOf","Infinity","test","rel","addPackage","opts","simplifySemVer","semVer","substring","split","replace","fetchPackage","pkgVersion","reponse","isLatestNeeded","pkgInfos","JSON","parse","repository_url","latest_release_number","getPackageConfig","jsonURL","Number","pkgConfig","loadPackageConfig","checkReadyToImport","async","caller","splice","pkgDeps","getOwnPropertyNames","depName","version","j","pkgScriptTags","pkgLinkTags","isAlreadyLoaded","opera","domLoaderTags","devLinkTag","devScriptTag","getTag","pkg","document","querySelector","head","call","getElementsByTagName","concat","getAttribute","index","createElement","setAttribute","src","href","insertBefore","appendChild","log","isAlreadyOk","pkgConfigURL","rawgitURL","pkgQuery","pkgq","join","domScriptTags","onload","pkgInfo","onerror"],"mappings":"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","file":"loader.min.js","sourcesContent":["/* the bower components loader for browsers\n ________________________________________________________________________________________\n *\n * Easly Import your components or libraries installed via bower to your project.\n * \n * @license MIT\n * @author  [Tindo N. Arsel](mailto:devtnga@gmail.com)\n*/\n\n// manage possible conflict with loader namespace definition.\nif (typeof bower !== 'undefined' && !(bower.components instanceof Object)) {\n\n   console.warn('Seem like `bower` namespace is use for another purpose. Taking risk of an overwrite ...');\n   window.bower = bower = {};\n   console.warn('Forcing `bower` namespace initialization ... done.');\n\n} else if (typeof bower === 'undefined') {\n\n   window.bower = {};\n}\n\n/* importing package is an interresting hack when we have to avoid duplicate import and manage dependencies.\n * the method here is to have a registry where we will add package's configuration in particular order (function of dependency or not).\n * package's configuration is an object build from `bower.json` assciated file.\n * dependencies will always be imported before package of which depends; this influences how order is done in packages's configuration registry.\n * package have to have a unique occurrence on the registry; this assure that we will not have duplicate component's import.\n * that particular registry is the *dependencies package's tree registry*.\n * there will be also a main registry which is the *local packages's registry*, that will content all project's components's configurations installed via bower.\n * there will be therefore a provided command line tools (`bowerder`) that will help developer to generate the considered *local packages's registry* for a target project.\n * if the loader can't use any associated *local packages's registry* to import packages, it will try to use Ajax API to resolve the operation.\n * bower components directory have to be provided to loader so that it can know where to find packages main files. (this can be done through the global `dir` property)\n * however setting a `data-bowerreg` attribute to bowerder's script tag will be sufficient to it for determination of some needed like `bower components directory`.\n * \n * with each import instruction, can be associated a callback function.\n * considered callback is executed when associated package's importation is fully done.\n * package's importation is fully done when all it main files and it dependencies main files (if defined) are loaded *in the DOM*.\n * a callback take an object as argument with the following properties:\n * `occured` : a boolean which inform if the associated package's importation was fully done or not (if an error occured or not);\n * `from` : a string which inform about the place where the error occured, possible value are \"browser\" or \"bowerder\";\n *    if the value is \"bowerder\" it's maybe an internal/connection error when loading package configuration (bower.json),\n *    if the value is \"browser\" it's maybe a 404/connection error on loading main files *in the DOM*;\n *    therefore, console is the place to see what really happen.\n * that object is usefull to check if there isn't an error (conditions are good) for some instructions.\n * in case of contionnal or timed importation, if a package is already fully imported or have already adressed a full loading process, the associated callback will be immediatly executed.\n * this is to introduce the fact that many callbacks can be associated to a package's importation via multiple `import's` instructions.\n * that said there will be a registry where we can acces to any package's associated callbacks, via the package's name.\n * \n * for some globals tasks, global callbacks can be managed through the special bowerder \"reserved\" package's named `#bowerder`.\n * global callback take an object as argument with the following properties:\n * `occured` : a boolean which inform if all package's importation was fully done or not (if an error occured or not);\n * `fromBrowser` : an array which inform about packages where error occured and if it was from \"browser\" loading operations;\n * `fromBowerder` : an array which inform about packages where error occured and if it was from \"bowerder\" loading operations;\n *    therefore, console is the place to see what really happen.\n *    \n * to better manage some stuff, the loader can set extras porperties through the `browser` object, which can be itself a property of the package's configuration object. \n * \n * packages can be loaded from online CDN service like [cdn.rawgit.com](https://rawgit.com).\n * that said, only packages present in the bower's registry are targets.\n * to make this possible, developer have to enable the `bower.cdn.usage` property.\n * therefore online package's loading method will have priority to local loading.\n * one of advantages of this functionality is the possibility to switch from local hosted dependencies to online hosting via cdn and vis versa,\n * without change concerned code in a associated project.\n*/\n\nbower.dir = './bower_components';  // bower base directory\nbower.devMode = false;             // development mode for more verbose in console\nbower.isRegStated = false;         // inform if the local registry state is notified (in console)\nbower.loadingCount = 0;            // number of package that are in loading process\nbower.total = 0;                   // total number of packages that must to be loaded\nbower.callbacks = {};              // packages's callback functions registry \nbower.packagesTree = [];           // packages's configuration registry\n\nbower.cdn = {\n   usage: false,   // allow bower to use code deliver network (using online bower's registry)\n   rawgit: {}      // for rawgit cdn url of availables packages to load\n}\n\nbower.browser = {         // these properties will help in some case for bowerder global processing.\n   loaded: false,         // inform if all given packages are fully imported\n   regState: 0,           // inform about the local registry state (if it's provided or not)\n   regTag: undefined,     // reference to *local packages's registry* script tag\n   loaderTag: undefined,  // reference to bowerder's script tag\n   waitingCB: [],         // index of callbacks's to be execute after full packages's importation \"in the DOM\" \n   waitingImport: [],     // for package that will wait for *local packages's registry* state, before to be imported\n   error: {occured: false, fromBrowser: [], fromBowerder: []},\n};\n\n\n/**\n * get the text reponse through an ajax request from a given path\n * @param   {string}   path     path where to get file's content\n * @param   {boolean}  isAsync  enable request asynchrone or not\n * @param   {function} callback the function to execute after the end of request process. take the returned object as argument \n * @returns {object}   content the answer informations with this properties {error: boolean, status: number, statusText: string, text: string}\n */\nbower.xhrGet = function (path, isAsync, callback) {\n\n   if (typeof path !== 'string' && !(path instanceof String)) {\n\n      console.error('bowerder: path must be give as a string');\n      return null;\n   }\n\n   isAsync = (typeof isAsync === 'boolean' || isAsync instanceof Boolean) ? isAsync : true;\n   callback = (typeof callback === 'function' || callback instanceof Function) ? callback : undefined;\n\n   var xhr = undefined;\n\n   if (window.XMLHttpRequest) {\n\n      xhr = new XMLHttpRequest(); // For Chrome, Firefox, Opera and others...\n\n      if (xhr.overrideMimeType)\n         xhr.overrideMimeType('text/xml'); // Avoid Safari’s bug\n   }\n   else if (window.ActiveXObject) {\n      // For Internet Explorer\n      try {\n         xhr = new ActiveXObject('Msxml2.XMLHTTP');  \n      } catch (e1) {\n         try {\n            xhr = new ActiveXObject('Microsoft.XMLHTTP');  \n         } catch (e2) {\n            console.warn( e1.message );\n            console.warn( e2.message );\n         }\n      }\n   }\n\n   if (!(xhr instanceof Object)) {\n\n      console.error(\"bowerder: Can’t init Ajax functionalities. Maybe it’s your browser version ?\");\n      return null;\n   }\n\n   // on soumet les champs de connexion à la page de traitement approprié pour vérification\n   xhr.open('GET', path, true);\n   // xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n   // Si la requêtte s'est exécutée sans erreur on recupère le resultat du traitement\n   xhr.send();\n\n   xhr.onreadystatechange = function() {\n\n      var response = {};\n      response.error = false;\n\n      if(xhr.readyState == 4 && xhr.status == 200) {\n\n         response.status = xhr.status;\n         response.text = xhr.responseText;\n\n         if (callback) callback( response );\n\n         return response;\n      } \n      else if (xhr.readyState == 4 && xhr.status != 200) {\n\n         response.status = xhr.status;\n         response.statusText = xhr.statusText;\n         response.error = true;\n         console.error('bowerder: Ajax request error (status: '+ xhr.status +'), try to check your connection. ');\n\n         if (callback) callback( response );\n\n         return response;\n      }\n   }  \n};\n\n/**\n * helpfull to determine if a package is in the packages's configuration registry\n * @param   {string} pkgName the name of the package\n * @returns {number} index of the first occurrence of the given package. -1 if it's isn't in the registry.\n */\nbower.packageIndex = function (pkgName) {\n\n   if (typeof pkgName !== 'string' && !(pkgName instanceof String)) {\n\n      console.error('bowerder:packageIndex: argument must be a string' );\n   }\n   else {\n\n      for (i in bower.packagesTree) {\n\n         if (bower.packagesTree[i].name === pkgName) return i;\n      }\n   }\n\n   return -1;\n};\n\n/**\n * helpfull to get a package's configuration from the registry\n * @param   {string} pkgName the name of the package\n * @returns {object} the first occurrence of the given package. undefined if it's isn't in the registry.\n */\nbower.package = function (pkgName) {\n\n   return bower.packagesTree[ bower.packageIndex( pkgName ) ];\n};\n\n/**\n * check the correct moment to execute callbacks associated to a package and do it.\n * @param {string} pkgName the name of a package\n */\nbower.checkCallback = function (pkgName) {\n\n   /* the hack here is to be sure that all associated main files of considered package are loaded in the browser.\n    * this is checked with a counter which content the number of main files that was loaded (event if the loading fail with browser loading process).\n    * therefore the package is fully imported when the counter is equal to total of the package's main files.\n    * callback is executed only if the package is fully imported.\n   */\n   if (!bower.package( pkgName ).browser.loaded) bower.package( pkgName ).browser.counter++;\n\n   if (bower.package( pkgName ).browser.counter === bower.package( pkgName ).browser.main.length) {\n\n      bower.package( pkgName ).browser.loaded = true; \n\n      if (bower.callbacks[ pkgName ]) {\n\n         bower.callbacks[ pkgName ].forEach( function (callback) {\n\n            callback( bower.package( pkgName ).browser.error );\n         });\n      }\n\n      // will check if all packages are fully imported (condition is good) for globals callbacks's executions\n      bower.ready(); \n   }\n}\n\n/**\n * usefull to run callbacks after full packages's importation \"in the DOM\".\n * @param {function} callback function to execute. If empty, the function will try to run waiting callbacks.\n */\nbower.ready = function (callback) {\n\n   if (callback) {\n\n      if (typeof callback !== 'function' && !(callback instanceof Function)) {\n\n         console.warn('bowerder:ready: argument must be a function' );\n      }\n      else {\n\n         if (!bower.callbacks['#bowerder']) bower.callbacks['#bowerder'] = [];\n\n         bower.callbacks['#bowerder'].push( callback );\n\n         /* with current ready's process, callback which is added to the callbacks's registry have the last index for the associated package,\n          * that index is keeped and will be use to access to that callback if necessary in certains conditions\n         */\n         bower.browser.waitingCB.push( bower.callbacks['#bowerder'].length - 1 );\n      }\n   }\n\n   if (bower.packagesTree.length > 0) bower.browser.loaded = true;\n\n   for (var i=0; i<bower.packagesTree.length; i++) {\n\n      if (!bower.packagesTree[i].browser.loaded) {\n\n         bower.browser.loaded = false;\n         break;\n      }\n   }\n\n   if (bower.browser.loaded) {\n\n      bower.browser.waitingCB.forEach( function (cbi) {\n\n         bower.callbacks['#bowerder'][cbi]( bower.browser.error );\n      });\n      // clean up (considering each callback have to be executed once)\n      bower.browser.waitingCB = [];\n   }\n};  \n\n/**\n * attach considered package's callbacks to it main files browser `load` event\n * @param   {Element}  node    element to attach callbacks on it `load` event\n * @param   {string}   pkgName package's name to use associated callbacks\n*/\nbower.attachPackageCB = function (node, pkgName) {\n\n   if (!(node instanceof Element)) {\n\n      console.warn('bowerder:attachPackageCB: argument must be an Element');\n      return null;\n   }\n\n   // Set up load listener. Test attachEvent first because IE9 has\n   // a subtle issue in its addEventListener and script onload firings that do not match the behavior of all other browsers with\n   // addEventListener support, which fire the onload event for a script right after the script execution. See:\n   // https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution\n   // UNFORTUNATELY Opera implements attachEvent but does not follow the script execution mode.\n   if (node.attachEvent &&\n       // Check if node.attachEvent is artificially added by custom script or natively supported by browser\n       // read https://github.com/requirejs/requirejs/issues/187\n       // if we can NOT find [native code] then it must NOT natively supported.\n       // in IE8, node.attachEvent does not have toString()\n       // Note the test for \"[native code\" with no closing brace, see: https://github.com/requirejs/requirejs/issues/273\n       !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&\n       !isOpera) {\n      // Probably IE. IE (at least 6-8) do not fire script onload right after executing the script, so\n      // we cannot tie the anonymous define call to a name.\n      // However, IE reports the script as being in 'interactive' readyState at the time of the define call.\n\n      node.attachEvent('onreadystatechange', function () { bower.checkCallback( pkgName ); });\n      // It would be great to add an error handler here to catch 404s in IE9+. \n      // However, onreadystatechange will fire before the error handler, so that does not help. \n      // If addEventListener is used, then IE will fire error before load, but we cannot\n      // use that pathway given the connect.microsoft.com issue mentioned above about not doing the 'script execute,\n      // then fire the script load event listener before execute next script' that other browsers do.\n      // Best hope: IE10 fixes the issues, and then destroys all installs of IE 6-9.\n      // node.attachEvent('onerror', context.onScriptError);\n   } else {\n\n      node.addEventListener('load', function () { bower.checkCallback( pkgName ); }, false);\n      node.addEventListener('error', function () { \n\n         bower.package( pkgName ).browser.error = {occured: true, from: 'browser'};\n         bower.browser.error.occured = true;\n         bower.browser.error.fromBrowser.push( pkgName );\n\n         bower.checkCallback( pkgName ); \n      }, false );\n   }\n}\n\n/**\n * helpfull to determine which html tag have to be used to import a component in the DOM\n * @param   {string} targetFile component's file to include\n * @returns {object} an object that contains informations about html tag to use\n */\nbower.parseTagType = function (targetFile) {\n\n   if (typeof targetFile !== 'string' && !(targetFile instanceof String)) {\n\n      console.error('bowerder:parseTagType: argument must be a string' );\n      targetFile = \"\";\n   }\n\n   var tag = {name: 'unknow', type: 'unknow'};\n   // get the target file extension\n   tag.fext = targetFile.slice((Math.max(0, targetFile.lastIndexOf('.')) || Infinity) + 1);\n\n   if (tag.fext === 'js') { // it's a js like file\n\n      tag.name = 'script';\n      tag.type = 'text/javascript';        \n   }\n   if (tag.fext === 'css' || tag.fext ==='scss' || tag.fext ==='sass' || tag.fext ==='less') { // it's a css like\n\n      tag.name = 'link';\n      tag.type = 'text/css';\n\n      if (/\\.css$/.test( targetFile )) tag.rel = 'stylesheet';\n      else tag.rel = 'stylesheet/'+ tag.fext;            \n   }\n   if (tag.fext === 'txt') { // it's a plain text like file\n\n      tag.name = 'link';\n      tag.type = 'text/plain';        \n      tag.rel = 'alternate';\n      // @TODO set the tag.title with the name of the targetFile (regex must be usefull here)\n   }\n\n   return tag;\n};\n\n/**\n * organize packages's tree dependencies, process their importation \"in the DOM\" with asssociated callback if available\n * @param   {string}   pkgName   package's name\n * @param   {string}   pkgCaller package's of package which depends of first (argument) given package. usefull for dependencies management.\n * @param   {number}   cbIndex   index of current associated callback in callbacks's registry (if given)\n */\nbower.addPackage = function (pkgName, opts) {\n\n   if (typeof pkgName !== 'string' && !(pkgName instanceof String)) {\n\n      console.error(\"bowerder:addPackage: package's name must be a string\");\n      return null;\n   }\n   if (opts && opts instanceof Object) {\n      \n      if (opts.caller && (typeof opts.caller !== 'string') && !(opts.caller instanceof String)) console.warn(\"bowerder:addPackage: package caller's name must be a string\");\n      if (opts.version && (typeof opts.version !== 'string') && !(opts.version instanceof String)) console.warn(\"bowerder:addPackage: package's version must be a string\");\n      if (opts.cbi && (typeof opts.cbi !== 'number') && !(opts.cbi instanceof Number)) console.warn(\"bowerder:addPackage: callback index must be a number\");\n   } \n   else if (opts && !(opts instanceof Object)) {\n      \n      console.error(\"bowerder:addPackage: package's options must be an object\");\n      return null;\n   }\n   \n   var isAlreadyOk = false;\n\n   /* check if package to load is already present in the registry.\n    * if it's a dependency, check if it's present in the registry before package of which depends.\n    * if so, nothing will be done, else the adding operation to the registry will be process.\n   */\n   if (bower.package( pkgName )) {\n\n      isAlreadyOk = true;\n\n      // if the package is already fully loaded *in the DOM*, the current associated callback is executed.\n      if (opts.cbi && bower.package( pkgName ).browser.loaded && bower.callbacks[ pkgName ]) {\n\n         bower.callbacks[ pkgName ][opts.cbi]( bower.package( pkgName ).browser.error );\n      }\n\n      if (opts.caller && (bower.packageIndex( opts.caller ) != -1) ) {\n         /* major browsers load and execute script included by another script asynchronously.\n          * the problem here is that, package which have dependencies have to be execute after them.\n          * therefore, for these package, it's primordial to load them synchronously.\n         */\n         bower.package( pkgName ).browser.async = false;\n         bower.package( opts.caller ).browser.async = false;\n\n         if (bower.packageIndex( opts.caller ) < bower.packageIndex( pkgName )) isAlreadyOk = false;\n      }\n   }\n   \n   if (!isAlreadyOk) { // process the adding operation to the registry.\n\n      // log (if isn't already done) the state of local registry if it isn't provided or well defined\n      if (bower.devMode && !(bower.components instanceof Object) && !bower.isRegStated) {\n\n         switch (bower.browser.regState) {\n            case 1:\n               console.warn('bowerder: local registry isn\\'t found, loader will try to import package through Ajax API.');\n               break;\n            case 2:\n               console.warn('bowerder: seems that local registry isn\\'t provided; if so, loader will try to import package through Ajax API.');\n               break;\n            default:\n               console.warn('bowerder: unexpected state of local registry; loader will try to import package through Ajax API.');\n               break;\n         }\n         \n         bower.isRegStated = true ;\n      }\n      \n      bower.loadingCount++;\n      bower.total++;\n\n      if ((bower.components instanceof Object) && bower.components[ pkgName ]) {\n        \n         var pkgConfig = bower.components[ pkgName ];\n         /* for reason due to size some properties in `bower.json` have been deleted with provided local registry (using bowerder on command line).\n          * `name` is one of them, and the reason of it was removed was to avoid duplication since as once can see, package's configuration is accessible with package's name.\n          * this is valable for `bower.components` (local registry), but not for `bower.packagesTree` (particular generated registry), which need that `name` property to be set.\n         */\n         pkgConfig.name = pkgName;\n\n         loadPackageConfig( pkgConfig );\n         \n         if (bower.cdn.usage) {\n            \n            fetchPackage( pkgName, opts.version, function () {\n               \n               checkReadyToImport(); \n            });\n         }\n         else checkReadyToImport();\n      }\n      else {\n\n         if ((bower.components instanceof Object) && !bower.components[ pkgName ]) {\n\n            console.warn(\"bowerder:addPackage: can't found `\"+ pkgName +\"` in project's local registry; will try to import package through Ajax API.\");\n         }\n\n         var pkgConfigURL = bower.dir +'/'+ pkgName +'/bower.json';\n         \n         if (bower.cdn.usage) {\n            \n            fetchPackage( pkgName, opts.version, function (rawgitURL) {\n                \n               if (rawgitURL) pkgConfigURL = rawgitURL + '/bower.json';\n               \n               getPackageConfig( pkgConfigURL );\n            });\n         }\n         else getPackageConfig( pkgConfigURL );\n      }\n      \n      \n      /**\n       * get a simplified version from a given range sementic version (see https://github.com/npm/node-semver)\n       * @param   {string}   semVer a valid range sementic version\n       * @returns {string} simplified version\n       */\n      function simplifySemVer (semVer) {\n         \n         if (semVer) {\n            // delete particular range operator and get a static version\n            if (/^\\D\\d/.test( semVer )) semVer = semVer.substring(1);\n            if (semVer.indexOf(' - ') !== -1) semVer = semVer.split(' - ')[1];\n            semVer = semVer.replace(' ', '');\n            if (/^\\d\\.\\d$/.test( semVer )) semVer += '.0';\n            if (semVer.indexOf('.') === -1) semVer += '.0.0';\n            \n            if (!/^\\d\\.\\d/.test( semVer )) console.warn('bowerder:addPackage: invalid sementic version: '+ semVer);\n         }\n         \n         return semVer;\n      }\n      \n      /**\n       * search package from online bower's registry and parse resulting informations that can help for loading process. \n       * @param {string}   pkgName  the name of a package\n       * @param {function} callback the function to execute after the end of request process. take the resulting rawgit url as argument \n       */\n      function fetchPackage( pkgName, pkgVersion, callback) {\n\n         // @TODO change this hack to get `bower.json`'s package directly from bower's registry (if it's better)\n         // @TODO the package's versionn or range version will be send to the futur `bowerder api` that will determine the appropiate versoin to load (v0.5.0)\n         bower.xhrGet('https://libraries.io/api/bower/'+ pkgName, true, function (reponse) {\n\n            var isLatestNeeded = false;\n            \n            if (!reponse.error) {\n\n               var pkgInfos = JSON.parse( reponse.text ); \n               \n               if (pkgInfos instanceof Object) {\n\n                  if (/^https:\\/\\/github.com/i.test( pkgInfos.repository_url )) {\n\n                     pkgVersion = simplifySemVer( pkgVersion ) || pkgInfos.latest_release_number || 'master';\n                     if (/^v/.test( pkgInfos.latest_release_number ) && /^\\d/.test( pkgVersion )) pkgVersion = 'v' + pkgVersion;\n                     if (pkgVersion === pkgInfos.latest_release_number) isLatestNeeded = true;\n                     // @TODO remove this test hack and only consider the else instruction when jquery's search will result to appropriate repository (https://github.com/jquery/jquery-dist)\n                     if (pkgName === 'jquery') {\n                        bower.cdn.rawgit[ pkgName ] = 'https://cdn.rawgit.com/'+ pkgInfos.repository_url.replace('https://github.com/', '') +'-dist' +'/'+ pkgVersion;\n                     }\n                     else bower.cdn.rawgit[ pkgName ] = 'https://cdn.rawgit.com/'+ pkgInfos.repository_url.replace('https://github.com/', '') +'/'+ pkgVersion;\n                  }\n                  else console.warn('bowerder:addPackage: can\\'t yet able to load `'+ pkgName +'` from '+ pkgInfos[i].repository_url +' repository.' );\n               }\n               else console.warn('bowerder:addPackage: invalid loaded meta-data of `'+ pkgName +'`.' );\n            }\n            else console.error('bowerder:addPackage: unable to find `'+ pkgName +'` from online registry.' );  \n            \n            if (callback) {\n               \n               if (isLatestNeeded) {\n                  /* there are libraries that have included `bower.json` after their latest release.\n                   * this cause the configuration not available when target that version or lower.\n                   * however, it's generally available from master.\n                   * @NOTE hope this hack will not be necessary with the futur online package's loading implementation from v0.5.0 \n                   */\n                  callback( bower.cdn.rawgit[ pkgName ].replace( pkgVersion, 'master') );\n               }\n               else callback( bower.cdn.rawgit[ pkgName ] );\n            }\n         });\n      }\n      \n      /**\n       * locally get and parse a `bower.json` config file of a package\n       * @param {string} jsonURL url where to get the `bower.json` of a package\n       */\n      function getPackageConfig (jsonURL) {\n         \n         bower.xhrGet( jsonURL, true, function (reponse) {\n\n            if (reponse.error) {\n\n               console.error('bowerder:addPackage: unable to load `'+ pkgName +'` component.' );\n\n               /* considering that the package will not be imported and\n                * then will not be added to the packages's configuration registry,\n                * associated callback functions are executed with error from bowerder.\n               */\n               if ((typeof opts.cbi === 'number' || opts.cbi instanceof Number) && bower.callbacks[ pkgName ]) {\n\n                  bower.callbacks[ pkgName ][opts.cbi]( {occured: true, from: 'bowerder'} );\n               } \n\n               bower.browser.error.occured = true;\n               bower.browser.error.fromBowerder.push( pkgName );                \n            }\n            else {\n\n               var pkgConfig = JSON.parse( reponse.text ); \n\n               if (pkgConfig instanceof Object) {\n\n                  delete pkgConfig['ignore'];\n                  delete pkgConfig['keywords'];\n                  delete pkgConfig['moduleType'];\n                  delete pkgConfig['resolutions'];\n\n                  loadPackageConfig( pkgConfig );\n               }\n               else {\n\n                  console.warn('bowerder:addPackage: unable to load `'+ pkgName +'` component.' );\n               }\n            } \n\n            checkReadyToImport();\n         });\n      }\n\n      /**\n       * register package's configuration with it dependencies (if defined) in the packages's tree registry.\n       * @param {object} pkgConfig package's configuration from it `bower.json`\n       * @private\n      */\n      function loadPackageConfig (pkgConfig) {\n\n         if (!(pkgConfig.browser instanceof Object)) pkgConfig.browser = {};\n         // by default,load and execute script asynchronously\n         pkgConfig.browser.async = true;\n         // by default, files to load from the package aren't yet imported\n         pkgConfig.browser.loaded = false;\n         // by default, set importation status to done without error  \n         pkgConfig.browser.error = {occured: false, from: undefined};\n         // init the number of imported file counter for the package\n         pkgConfig.browser.counter = 0;\n\n         /* minification is a way for developer to have for some files a better loading optimization. \n          * however, `bower.json` spec do not allow to use minified files as mains files for a component.\n          * developers use to set associated `main` property with sources or developments files.\n          * considering how web projects are now build, that pratice isn't advantageous for browsers.\n          * indeed, set an `index.scss` or an unminified `index.js` files *(depending of size)* as main file isn't good for browsers to digest.\n          * that why is now recommended to also set a `browser: {main: []}` properties for mains files that browsers can easly digest.\n          * minified files with sourcemaps are specialy welcome in that case.\n          * bowerder will use that properties to load component *in the DOM*; if they aren't set, it will use the `main` property. \n          * here is an example illustration for bowerder to well do it job:\n          * // bower.json\n          *    main: [\"dist/index.scss\", \"dist/index.coffee\"], // keep bower json spec\n          *    browser: {\n          *       main: [\"dist/index.min.css\", \"dist/index.min.js\"] // for browsers through bowerder\n          *    }\n          *    ... // others properties\n         */\n         if (!pkgConfig.browser.main) {\n\n            if (!pkgConfig.main) {\n\n               console.warn(\"bowerder:addPackage: there isn't main files indication for \"+ pkgName);\n               pkgConfig.main = [];\n            }\n\n            pkgConfig.browser.main = (typeof pkgConfig.main === 'string') ? [pkgConfig.main] : pkgConfig.main;\n         }\n\n         /* if `opts.caller` is set, then current loading package adress by `pkgName` is a dependency.\n          * therefore, it have to be added before the `opts.caller` in the packages's configuration registry.\n          * else it's just a package to add in the considered registry.\n         */\n         if (opts.caller) {\n\n            // mark package to be synchronously loaded and executed\n            pkgConfig.browser.async = false;\n            bower.package( opts.caller ).browser.async = false;\n\n            if (bower.packageIndex( opts.caller ) != -1) {\n\n               bower.packagesTree.splice( bower.packageIndex( opts.caller ), 0, pkgConfig);\n            }\n         }\n         else {\n\n            bower.packagesTree.push( pkgConfig );\n         }\n\n         // if the current loading package have dependencies, then also process their loading\n         if (pkgConfig['dependencies']) {\n\n            var pkgDeps = Object.getOwnPropertyNames( pkgConfig['dependencies'] );\n\n            pkgDeps.forEach( function (depName) {\n\n               bower.addPackage( depName, {caller: pkgConfig['name'], version: pkgConfig['dependencies'][depName]});\n            });\n         }\n      }\n\n      /**\n       * make sure that loadings packages's configuration process are ok with good dependencies organization,\n       * and proceed to packages importation *in the DOM* with correct order and associated behavior (callback, ...).\n       * @private\n      */\n      function checkReadyToImport() {\n\n         bower.loadingCount--;\n\n         // when all the loading package process are finished, process their importation on the DOM.\n         if (bower.loadingCount === 0) {\n\n            /* if all loading package's configuration process have failed, \n             * directly run globals callbacks (if they are).\n             * this, considering the fact that error can be check from callback by using the `error` argument.\n            */\n            if (bower.packagesTree.length === 0) {\n\n               bower.browser.loaded = true;\n               bower.ready();\n            }\n            else {\n\n               // be sure to have unique package occurence in package's tree\n               for (var i=0; i < bower.packagesTree.length; i++) {\n\n                  for (var j=i+1; j < bower.packagesTree.length; j++) {\n\n                     if (bower.packagesTree[i].name === bower.packagesTree[j].name) {\n\n                        bower.packagesTree.splice( j, 1);\n                        bower.total--;\n\n                        j--;\n                     }\n                  }\n               }\n\n               var pkgScriptTags = [],\n                   pkgLinkTags = [],\n                   isAlreadyLoaded = false,\n                   // Oh the tragedy, detecting opera. See the usage of isOpera for reason.\n                   isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',\n                   loaderTag = undefined,\n                   domLoaderTags = undefined,\n                   devLinkTag = undefined,   // first custom link tag include by developer *in the document's <head>*\n                   devScriptTag = undefined, // first custom Script tag include by developer *in the document's <head>*\n                   getTag = undefined;       // supported tag\n\n               bower.packagesTree.forEach( function (pkg) {\n\n                  isAlreadyLoaded = false;\n                  /* before include a loader tag in the DOM, it's primordial to check if the associated file isn't already loaded in.\n                   * this assure to have an unique instance of a package in the DOM include by our `bower loader`.\n                  */\n                  if (document.querySelector) {\n                     // efficient : this is for all major browsers and IE>8\n                     if (document.head.querySelector('[data-bowerpkg =\"'+pkg.name+'\"]')) isAlreadyLoaded = true;\n                  }\n                  else { // alternative with more hack : this is specialy for IE<=8\n\n                     domLoaderTags = [].slice.call( document.head.getElementsByTagName('link') );\n                     domLoaderTags = domLoaderTags.concat( [].slice.call( document.head.getElementsByTagName('scrpit') ) );\n                     for (var j=0; j < domLoaderTags.length; j++) {\n\n                        if (domLoaderTags[j].getAttribute('data-bowerpkg') === pkg.name ) {\n\n                           isAlreadyLoaded = true;\n                           break;\n                        }\n                     }\n                  }\n\n                  if (!isAlreadyLoaded) {\n\n                     for (index in pkg.browser.main) {\n\n                        getTag = bower.parseTagType( pkg.browser.main[ index ] );\n\n                        if (getTag.name === 'script') { \n\n                           loaderTag = document.createElement('script');\n                           loaderTag.setAttribute('data-bowerpkg', pkg.name);\n                           loaderTag.type = getTag.type;\n                           loaderTag.async = pkg.browser.async;\n\n                           /* with time, for other script support, paid attention to `load` event issue for some file by browsers.\n                            * look at comments below for `link` tag hack for more details.\n                           */\n                           bower.attachPackageCB( loaderTag, pkg.name );\n\n                           if (bower.cdn.usage && bower.cdn.rawgit[ pkg.name ]) {\n                              \n                              loaderTag.src = bower.cdn.rawgit[ pkg.name ] +'/'+ pkg.browser.main[ index ];\n                           }\n                           else loaderTag.src = bower.dir +'/'+ pkg.name +'/'+ pkg.browser.main[ index ];\n\n                           pkgScriptTags.push( loaderTag );\n                        }\n                        if (getTag.name === 'link') {\n\n                           loaderTag = document.createElement('link');\n                           loaderTag.setAttribute('data-bowerpkg', pkg.name);\n                           loaderTag.rel = getTag.rel;\n                           loaderTag.type = getTag.type;\n\n                           /* browsers (as tested on firefox and chrome) seems to not execute event listeners \n                            * attached to `load` envent of some file (exception for css).\n                            * unless will find hack to resolve that, callbacks assignement will be directly checked\n                            * before considered files will have their path set to be included to the DOM.\n                           */\n                           if (getTag.fext !== \"css\") {\n\n                              if (bower.devMode) console.warn(\"bowerder: can't attach callback to `onload` event of \"+ pkg.name +\"/\"+ pkg.browser.main[ index ]);\n                              bower.checkCallback( pkg.name );\n                           }\n                           else bower.attachPackageCB( loaderTag, pkg.name );\n\n                           if (bower.cdn.usage && bower.cdn.rawgit[ pkg.name ]) {\n\n                              loaderTag.href = bower.cdn.rawgit[ pkg.name ] +'/'+ pkg.browser.main[ index ];\n                           }\n                           else loaderTag.href = bower.dir +'/'+ pkg.name +'/'+ pkg.browser.main[ index ];\n\n                           pkgLinkTags.push( loaderTag );\n                        }  \n                        if (getTag.name === 'unknow') {\n\n                           // console.warn('bowerder: unable to load unsupported file: '+ bower.dir +'/'+ pkg.name +'/'+ pkg.browser.main[ index ]);\n                           // count the file for loading's fetching state \n                           bower.package( pkg.name ).browser.counter++;\n                        }                       \n                     }\n                  }\n               });\n\n               /* generally, developer use to include custom stylesheets or scripts,\n                * to overwrite library's properties or functions.\n                * this is done by including library first, before that custom hacks.\n                * therefore bowerder have to do the same to maintain that habit.\n                * loader can identify it imported packages with the `data-bowerpkg` attribute.\n                * it just to make sure to import them before non `data-bowerpkg` considered tag *in document <head>*.\n               */ \n               domLoaderTags = document.head.getElementsByTagName('link');\n               for (var i=0; i < domLoaderTags.length; i++) {\n\n                  if (!domLoaderTags[i].getAttribute('data-bowerpkg') && domLoaderTags[i].rel && (domLoaderTags[i].rel !== 'icon')) {\n\n                     devLinkTag = domLoaderTags[i];\n                     break;\n                  }\n               }\n               domLoaderTags = document.head.getElementsByTagName('script');\n               for (var i=0; i < domLoaderTags.length; i++) {\n\n                  if (!domLoaderTags[i].getAttribute('data-bowerpkg')) {\n\n                     devScriptTag = domLoaderTags[i];\n                     break;\n                  }\n               }\n\n               // Link tags importation process \"in the DOM\"\n               if (devLinkTag) {\n\n                  pkgLinkTags.forEach( function (loaderTag) {\n\n                     document.head.insertBefore( loaderTag, devLinkTag );\n                  });\n               }\n               else {\n\n                  pkgLinkTags.forEach( function (loaderTag) {\n\n                     document.head.appendChild( loaderTag );\n                  });\n               }\n\n               // Script tags importation process \"in the DOM\"\n               if (devScriptTag) {\n\n                  pkgScriptTags.forEach( function (loaderTag) {\n\n                     document.head.insertBefore( loaderTag, devScriptTag );\n                  });\n               }\n               else {\n\n                  pkgScriptTags.forEach( function (loaderTag) {\n\n                     document.head.appendChild( loaderTag );\n                  });\n               }\n\n               if (bower.devMode) console.log( bower.packagesTree );\n            }\n         }\n      }\n   }\n};\n\n\n/**\n * import packages \"in the DOM\" with their dependecies \n * @param   {string}   pkgQuery  package's name (with a specified version, ex: name#1.0.0)\n * @param   {function} callback function to run after full package's importation\n*/\nbower.import = function (pkgQuery, callback) {\n\n   if (typeof pkgQuery !== 'string' && !(pkgQuery instanceof String)) {\n\n      console.error('bowerder:import: argument must be a string' );\n      return null;\n   }\n   \n   // a query can be the package's name with or without a specified version (ex: name#1.0.0) \n   pkgQuery = pkgQuery.split('#');\n   var pkgq = {name: pkgQuery[0], version: pkgQuery[1]};\n   // given query is normaly a string so re-formatting is welcome after above manipulations\n   pkgQuery = pkgQuery.join('#');\n\n   if (callback) {\n\n      if (typeof callback !== 'function' && !(callback instanceof Function)) {\n\n         console.warn('bowerder:import: argument must be a function' );\n      }\n      else {\n\n         if (!bower.callbacks[ pkgq.name ]) bower.callbacks[ pkgq.name ] = [];\n\n         bower.callbacks[ pkgq.name ].push( callback );\n\n         /* with current import's process, callback which is added to the callbacks's registry have the last index.\n          * that index is keeped and will be use to access to that callback if necessary in certains conditions.\n          * loader will be able to import package when the bower components's local registry state will be determinate.\n         */\n         if (!(bower.components instanceof Object) && bower.components !== null) {\n\n            bower.browser.waitingImport.push( {name: pkgq.name, version: pkgq.version, cbi: (bower.callbacks[ pkgq.name ].length - 1)} );\n         }\n         else bower.addPackage( pkgq.name, {version: pkgq.version, cbi: (bower.callbacks[ pkgq.name ].length - 1)} );\n      }\n   }\n   else {\n\n      if (!(bower.components instanceof Object) && bower.components !== null) {\n\n         bower.browser.waitingImport.push( {name: pkgq.name, version: pkgq.version, cbi: undefined} );\n      }\n      else bower.addPackage( pkgq.name, {version: pkgq.version} );\n   } \n\n};\n\n\n/* first execution zone\n------------------------*/\n/* developer can manually include the bower components's local registry *in the DOM*.\n * if not, the bowerder have to try to include it by itself for better performence for loading process.\n*/\nif (bower.components === undefined) {\n   /* loader script have to be include *in the DOM* with the `data-bowerreg` attribute setting.\n    * that attribute will help to know which tag have to be use to automate local packages's registry loading.\n   */\n   if (document.querySelector) {\n      // efficient : this is for all major browsers and IE>8\n      bower.browser.loaderTag = document.querySelector('script[data-bowerreg]');\n   }\n   else { // alternative with more hack : this is specialy for IE<=8\n\n      var domScriptTags = document.getElementsByTagName('scrpit');\n\n      for (var j=0; j < domScriptTags.length; j++) {\n\n         if (domScriptTags[j].getAttribute('data-bowerreg')) {\n\n            bower.browser.loaderTag = domScriptTags[j];\n            break;\n         }\n      }\n   }\n\n   if (bower.browser.loaderTag) {\n\n      // assuming that loader path will usually be `path-to-bowerdir/bowerder/dist/loader.js`\n      bower.dir = bower.browser.loaderTag.src;\n      for (var i=0; i<3; i++) bower.dir = bower.dir.slice(0, bower.dir.lastIndexOf('/') );\n\n      bower.browser.regTag = document.createElement('script');\n      bower.browser.regTag.onload = function () {\n\n         if (!(bower.components instanceof Object)) {\n\n            bower.components = null; // will allow not already run import's function call to skip waiting import step\n            bower.browser.regState = 1; // local registry isn't found, maybe is provided but isn't well defined\n         }\n\n         bower.browser.waitingImport.forEach( function (pkgInfo) {\n\n            bower.addPackage( pkgInfo.name, {version:  pkgInfo.version, cbi: pkgInfo.cbi} );\n         });\n         bower.browser.waitingImport = [];\n      };\n      bower.browser.regTag.onreadystatechange = bower.browser.regTag.onerror = bower.browser.regTag.onload;\n\n      bower.browser.regTag.setAttribute('data-bowerpkg', '#bowerder');\n      bower.browser.regTag.src = bower.dir +'/.bowerreg.js';\n\n      document.head.appendChild( bower.browser.regTag );\n   }\n   else {\n\n      bower.components = null; // will allow not already run import's function call to skip waiting import step\n      bower.browser.regState = 2; // local registry isn't provided\n   }\n}"],"sourceRoot":"/source/"}