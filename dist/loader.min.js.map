{"version":3,"sources":["loader.js"],"names":["bower","components","Object","window","console","warn","dir","devMode","isRegStated","loadingCount","total","callbacks","packagesTree","cdn","usage","rawgit","browser","loaded","regState","regTag","undefined","loaderTag","waitingCB","waitingImport","error","occured","fromBrowser","fromBowerder","xhrGet","path","isAsync","callback","String","Boolean","Function","xhr","XMLHttpRequest","overrideMimeType","ActiveXObject","e1","e2","message","open","send","onreadystatechange","response","readyState","status","text","responseText","statusText","packageIndex","pkgName","i","name","checkCallback","counter","main","length","forEach","ready","push","cbi","attachPackageCB","node","Element","attachEvent","toString","indexOf","isOpera","addEventListener","from","parseTagType","targetFile","tag","type","fext","slice","Math","max","lastIndexOf","Infinity","test","rel","addPackage","opts","simplifySemVer","semVer","substring","split","replace","fetchPackage","pkgVersion","reponse","pkgInfos","JSON","parse","repository_url","latest_release_number","getPackageConfig","jsonURL","Number","pkgConfig","loadPackageConfig","checkReadyToImport","Array","async","ignore","target","RegExp","log","filter","file","include","concat","caller","splice","pkgDeps","getOwnPropertyNames","depName","version","j","pkgScriptTags","pkgLinkTags","isAlreadyLoaded","opera","domLoaderTags","devLinkTag","devScriptTag","getTag","pkg","document","querySelector","head","call","getElementsByTagName","getAttribute","index","createElement","setAttribute","src","href","insertBefore","appendChild","isAlreadyOk","pkgConfigURL","rawgitURL","pkgQuery","options","pkgq","join","cbIndex","fileOpts","domScriptTags","onload","pkgInfo","onerror"],"mappings":"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","file":"loader.min.js","sourcesContent":["/* the bower components loader for browsers\n ________________________________________________________________________________________\n *\n * Easly Import your components or libraries installed via bower to your project.\n * \n * @license MIT\n * @author  [Tindo N. Arsel](mailto:devtnga@gmail.com)\n*/\n\n// manage possible conflict with loader namespace definition.\nif (typeof bower !== 'undefined' && !(bower.components instanceof Object)) {\n\n   console.warn('Seem like `bower` namespace is use for another purpose. Taking risk of an overwrite ...');\n   window.bower = bower = {};\n   console.warn('Forcing `bower` namespace initialization ... done.');\n\n} else if (typeof bower === 'undefined') {\n\n   window.bower = {};\n}\n\n/* importing package is an interresting hack when we have to avoid duplicate import and manage dependencies.\n * the method here is to have a registry where we will add package's configuration in particular order (function of dependency or not).\n * package's configuration is an object build from `bower.json` assciated file.\n * dependencies will always be imported before package of which depends; this influences how order is done in packages's configuration registry.\n * package have to have a unique occurrence on the registry; this assure that we will not have duplicate component's import.\n * that particular registry is the *dependencies package's tree registry*.\n * there will be also a main registry which is the *local packages's registry*, that will content all project's components's configurations installed via bower.\n * there will be therefore a provided command line tools (`bowerder`) that will help developer to generate the considered *local packages's registry* for a target project.\n * if the loader can't use any associated *local packages's registry* to import packages, it will try to use Ajax API to resolve the operation.\n * bower components directory have to be provided to loader so that it can know where to find packages main files. (this can be done through the global `dir` property)\n * however setting a `data-bowerreg` attribute to bowerder's script tag will be sufficient to it for determination of some needed like `bower components directory`.\n * \n * with each import instruction, can be associated a callback function.\n * considered callback is executed when associated package's importation is fully done.\n * package's importation is fully done when all it main files and it dependencies main files (if defined) are loaded *in the DOM*.\n * a callback take an object as argument with the following properties:\n * `occured` : a boolean which inform if the associated package's importation was fully done or not (if an error occured or not);\n * `from` : a string which inform about the place where the error occured, possible value are \"browser\" or \"bowerder\";\n *    if the value is \"bowerder\" it's maybe an internal/connection error when loading package configuration (bower.json),\n *    if the value is \"browser\" it's maybe a 404/connection error on loading main files *in the DOM*;\n *    therefore, console is the place to see what really happen.\n * that object is usefull to check if there isn't an error (conditions are good) for some instructions.\n * in case of contionnal or timed importation, if a package is already fully imported or have already adressed a full loading process, the associated callback will be immediatly executed.\n * this is to introduce the fact that many callbacks can be associated to a package's importation via multiple `import's` instructions.\n * that said there will be a registry where we can acces to any package's associated callbacks, via the package's name.\n * \n * for some globals tasks, global callbacks can be managed through the special bowerder \"reserved\" package's named `#bowerder`.\n * global callback take an object as argument with the following properties:\n * `occured` : a boolean which inform if all package's importation was fully done or not (if an error occured or not);\n * `fromBrowser` : an array which inform about packages where error occured and if it was from \"browser\" loading operations;\n * `fromBowerder` : an array which inform about packages where error occured and if it was from \"bowerder\" loading operations;\n *    therefore, console is the place to see what really happen.\n *    \n * to better manage some stuff, the loader can set extras porperties through the `browser` object, which can be itself a property of the package's configuration object. \n * \n * packages can be loaded from online CDN service like [cdn.rawgit.com](https://rawgit.com).\n * that said, only packages present in the bower's registry are targets.\n * to make this possible, developer have to enable the `bower.cdn.usage` property.\n * therefore online package's loading method will have priority to local loading.\n * one of advantages of this functionality is the possibility to switch from local hosted dependencies to online hosting via cdn and vis versa,\n * without change concerned code in a associated project.\n * \n * developer can target a package's version to load; however it will be only considered by the loader with online loading mode through CDN.\n * indeed, for local loading, the loader will considered that, dependencies and appropriates versions will be managed by `bower` through command tools (install, update, ...).\n * targeting a package's version can be done through this syntax: `pkg-name#version` (ex: vue#1.0.26). [see](https://semver.org) for supported version sementic.\n * \n * developer can decide to include or exclude some package's associated files. that said, for exclusion, developer can use global selector `*` (ex: *.scss, theme-*.css) which isn't supported in inclusion case.\n * \n * @TODO (v0.9.0 or higher) thing about manage appropriate package's version to load (online loading mode) when have duplicate importation (seems that load the highest of two can be a good idea. ex: vue#1.0.25 < vue#1.0.26 then load vue#1.0.26)\n*/\n\nbower.dir = './bower_components';  // bower base directory\nbower.devMode = false;             // development mode for more verbose in console\nbower.isRegStated = false;         // inform if the local registry state is notified (in console)\nbower.loadingCount = 0;            // number of package that are in loading process\nbower.total = 0;                   // total number of packages that must to be loaded\nbower.callbacks = {};              // packages's callback functions registry \nbower.packagesTree = [];           // packages's configuration registry\n\nbower.cdn = {\n   usage: false,   // allow bower to use code deliver network (using online bower's registry)\n   rawgit: {}      // for rawgit cdn url of availables packages to load\n}\n\nbower.browser = {         // these properties will help in some case for bowerder global processing.\n   loaded: false,         // inform if all given packages are fully imported\n   regState: 0,           // inform about the local registry state (if it's provided or not)\n   regTag: undefined,     // reference to *local packages's registry* script tag\n   loaderTag: undefined,  // reference to bowerder's script tag\n   waitingCB: [],         // index of callbacks's to be execute after full packages's importation \"in the DOM\" \n   waitingImport: [],     // for package that will wait for *local packages's registry* state, before to be imported\n   error: {occured: false, fromBrowser: [], fromBowerder: []},\n};\n\n\n/**\n * get the text reponse through an ajax request from a given path\n * @param   {string}   path     path where to get file's content\n * @param   {boolean}  isAsync  enable request asynchrone or not\n * @param   {function} callback the function to execute after the end of request process. take the returned object as argument \n * @returns {object}   content the answer informations with this properties {error: boolean, status: number, statusText: string, text: string}\n */\nbower.xhrGet = function (path, isAsync, callback) {\n\n   if (typeof path !== 'string' && !(path instanceof String)) {\n\n      console.error('bowerder: path must be give as a string');\n      return null;\n   }\n\n   isAsync = (typeof isAsync === 'boolean' || isAsync instanceof Boolean) ? isAsync : true;\n   callback = (typeof callback === 'function' || callback instanceof Function) ? callback : undefined;\n\n   var xhr = undefined;\n\n   if (window.XMLHttpRequest) {\n\n      xhr = new XMLHttpRequest(); // For Chrome, Firefox, Opera and others...\n\n      if (xhr.overrideMimeType)\n         xhr.overrideMimeType('text/xml'); // Avoid Safari’s bug\n   }\n   else if (window.ActiveXObject) {\n      // For Internet Explorer\n      try {\n         xhr = new ActiveXObject('Msxml2.XMLHTTP');  \n      } catch (e1) {\n         try {\n            xhr = new ActiveXObject('Microsoft.XMLHTTP');  \n         } catch (e2) {\n            console.warn( e1.message );\n            console.warn( e2.message );\n         }\n      }\n   }\n\n   if (!(xhr instanceof Object)) {\n\n      console.error(\"bowerder: Can’t init Ajax functionalities. Maybe it’s your browser version ?\");\n      return null;\n   }\n\n   // on soumet les champs de connexion à la page de traitement approprié pour vérification\n   xhr.open('GET', path, true);\n   // xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n   // Si la requêtte s'est exécutée sans erreur on recupère le resultat du traitement\n   xhr.send();\n\n   xhr.onreadystatechange = function() {\n\n      var response = {};\n      response.error = false;\n\n      if(xhr.readyState == 4 && xhr.status == 200) {\n\n         response.status = xhr.status;\n         response.text = xhr.responseText;\n\n         if (callback) callback( response );\n\n         return response;\n      } \n      else if (xhr.readyState == 4 && xhr.status != 200) {\n\n         response.status = xhr.status;\n         response.statusText = xhr.statusText;\n         response.error = true;\n         console.error('bowerder: Ajax request error (status: '+ xhr.status +'), try to check your connection. ');\n\n         if (callback) callback( response );\n\n         return response;\n      }\n   }  \n};\n\n/**\n * helpfull to determine if a package is in the packages's configuration registry\n * @param   {string} pkgName the name of the package\n * @returns {number} index of the first occurrence of the given package. -1 if it's isn't in the registry.\n */\nbower.packageIndex = function (pkgName) {\n\n   if (typeof pkgName !== 'string' && !(pkgName instanceof String)) {\n\n      console.error('bowerder:packageIndex: argument must be a string' );\n   }\n   else {\n\n      for (i in bower.packagesTree) {\n\n         if (bower.packagesTree[i].name === pkgName) return i;\n      }\n   }\n\n   return -1;\n};\n\n/**\n * helpfull to get a package's configuration from the registry\n * @param   {string} pkgName the name of the package\n * @returns {object} the first occurrence of the given package. undefined if it's isn't in the registry.\n */\nbower.package = function (pkgName) {\n\n   return bower.packagesTree[ bower.packageIndex( pkgName ) ];\n};\n\n/**\n * check the correct moment to execute callbacks associated to a package and do it.\n * @param {string} pkgName the name of a package\n */\nbower.checkCallback = function (pkgName) {\n\n   /* the hack here is to be sure that all associated main files of considered package are loaded in the browser.\n    * this is checked with a counter which content the number of main files that was loaded (event if the loading fail with browser loading process).\n    * therefore the package is fully imported when the counter is equal to total of the package's main files.\n    * callback is executed only if the package is fully imported.\n   */\n   if (!bower.package( pkgName ).browser.loaded) bower.package( pkgName ).browser.counter++;\n\n   if (bower.package( pkgName ).browser.counter === bower.package( pkgName ).browser.main.length) {\n\n      bower.package( pkgName ).browser.loaded = true; \n\n      if (bower.callbacks[ pkgName ]) {\n\n         bower.callbacks[ pkgName ].forEach( function (callback) {\n\n            callback( bower.package( pkgName ).browser.error );\n         });\n      }\n\n      // will check if all packages are fully imported (condition is good) for globals callbacks's executions\n      bower.ready(); \n   }\n}\n\n/**\n * usefull to run callbacks after full packages's importation \"in the DOM\".\n * @param {function} callback function to execute. If empty, the function will try to run waiting callbacks.\n */\nbower.ready = function (callback) {\n\n   if (callback) {\n\n      if (typeof callback !== 'function' && !(callback instanceof Function)) {\n\n         console.warn('bowerder:ready: argument must be a function' );\n      }\n      else {\n\n         if (!bower.callbacks['#bowerder']) bower.callbacks['#bowerder'] = [];\n\n         bower.callbacks['#bowerder'].push( callback );\n\n         /* with current ready's process, callback which is added to the callbacks's registry have the last index for the associated package,\n          * that index is keeped and will be use to access to that callback if necessary in certains conditions\n         */\n         bower.browser.waitingCB.push( bower.callbacks['#bowerder'].length - 1 );\n      }\n   }\n\n   if (bower.packagesTree.length > 0) bower.browser.loaded = true;\n\n   for (var i=0; i<bower.packagesTree.length; i++) {\n\n      if (!bower.packagesTree[i].browser.loaded) {\n\n         bower.browser.loaded = false;\n         break;\n      }\n   }\n\n   if (bower.browser.loaded) {\n\n      bower.browser.waitingCB.forEach( function (cbi) {\n\n         bower.callbacks['#bowerder'][cbi]( bower.browser.error );\n      });\n      // clean up (considering each callback have to be executed once)\n      bower.browser.waitingCB = [];\n   }\n};  \n\n/**\n * attach considered package's callbacks to it main files browser `load` event\n * @param   {Element}  node    element to attach callbacks on it `load` event\n * @param   {string}   pkgName package's name to use associated callbacks\n*/\nbower.attachPackageCB = function (node, pkgName) {\n\n   if (!(node instanceof Element)) {\n\n      console.warn('bowerder:attachPackageCB: argument must be an Element');\n      return null;\n   }\n\n   // Set up load listener. Test attachEvent first because IE9 has\n   // a subtle issue in its addEventListener and script onload firings that do not match the behavior of all other browsers with\n   // addEventListener support, which fire the onload event for a script right after the script execution. See:\n   // https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution\n   // UNFORTUNATELY Opera implements attachEvent but does not follow the script execution mode.\n   if (node.attachEvent &&\n       // Check if node.attachEvent is artificially added by custom script or natively supported by browser\n       // read https://github.com/requirejs/requirejs/issues/187\n       // if we can NOT find [native code] then it must NOT natively supported.\n       // in IE8, node.attachEvent does not have toString()\n       // @NOTE the test for \"[native code\" with no closing brace, see: https://github.com/requirejs/requirejs/issues/273\n       !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&\n       !isOpera) {\n      // Probably IE. IE (at least 6-8) do not fire script onload right after executing the script, so\n      // we cannot tie the anonymous define call to a name.\n      // However, IE reports the script as being in 'interactive' readyState at the time of the define call.\n\n      node.attachEvent('onreadystatechange', function () { bower.checkCallback( pkgName ); });\n      // It would be great to add an error handler here to catch 404s in IE9+. \n      // However, onreadystatechange will fire before the error handler, so that does not help. \n      // If addEventListener is used, then IE will fire error before load, but we cannot\n      // use that pathway given the connect.microsoft.com issue mentioned above about not doing the 'script execute,\n      // then fire the script load event listener before execute next script' that other browsers do.\n      // Best hope: IE10 fixes the issues, and then destroys all installs of IE 6-9.\n      // node.attachEvent('onerror', context.onScriptError);\n   } else {\n\n      node.addEventListener('load', function () { bower.checkCallback( pkgName ); }, false);\n      node.addEventListener('error', function () { \n\n         bower.package( pkgName ).browser.error = {occured: true, from: 'browser'};\n         bower.browser.error.occured = true;\n         bower.browser.error.fromBrowser.push( pkgName );\n\n         bower.checkCallback( pkgName ); \n      }, false );\n   }\n}\n\n/**\n * helpfull to determine which html tag have to be used to import a component in the DOM\n * @param   {string} targetFile component's file to include\n * @returns {object} an object that contains informations about html tag to use\n */\nbower.parseTagType = function (targetFile) {\n\n   if (typeof targetFile !== 'string' && !(targetFile instanceof String)) {\n\n      console.error('bowerder:parseTagType: argument must be a string');\n      targetFile = \"\";\n   }\n\n   var tag = {name: 'unknow', type: 'unknow'};\n   // get the target file extension\n   tag.fext = targetFile.slice((Math.max(0, targetFile.lastIndexOf('.')) || Infinity) + 1);\n\n   if (tag.fext === 'js') { // it's a js like file\n\n      tag.name = 'script';\n      tag.type = 'text/javascript';        \n   }\n   if (tag.fext === 'css' || tag.fext ==='scss' || tag.fext ==='sass' || tag.fext ==='less') { // it's a css like\n\n      tag.name = 'link';\n      tag.type = 'text/css';\n\n      if (/\\.css$/.test( targetFile )) tag.rel = 'stylesheet';\n      else tag.rel = 'stylesheet/'+ tag.fext;            \n   }\n   if (tag.fext === 'txt') { // it's a plain text like file\n\n      tag.name = 'link';\n      tag.type = 'text/plain';        \n      tag.rel = 'alternate';\n      // @TODO set the tag.title with the name of the targetFile (regex must be usefull here)\n   }\n\n   return tag;\n};\n\n/**\n * organize packages's tree dependencies, process their importation \"in the DOM\" with asssociated callback if available\n * @param   {string}   pkgName   package's name\n * @param   {object}   opts associated options for importation process:\n *                           `caller`: package which depends of this (argument focused by `pkgName`) given package. usefull for dependencies management,\n *                          `version`: target package's version to load (only considered for online loading through CDN),\n *                              `cbi`: index of current associated callback in callbacks's registry (if given),\n *                          `include`: an array of extra package's files to also load, \n *                           `ignore`: an array of package's files to exclude and not load \n */\nbower.addPackage = function (pkgName, opts) {\n\n   if (typeof pkgName !== 'string' && !(pkgName instanceof String)) {\n\n      console.error(\"bowerder:addPackage: package's name must be a string\");\n      return null;\n   }\n   if (opts && opts instanceof Object) {\n      \n      if (opts.caller && (typeof opts.caller !== 'string') && !(opts.caller instanceof String)) console.warn(\"bowerder:addPackage: package caller's name must be a string\");\n      if (opts.version && (typeof opts.version !== 'string') && !(opts.version instanceof String)) console.warn(\"bowerder:addPackage: package's version must be a string\");\n      if (opts.cbi && (typeof opts.cbi !== 'number') && !(opts.cbi instanceof Number)) console.warn(\"bowerder:addPackage: callback index must be a number\");\n   } \n   else if (opts && !(opts instanceof Object)) {\n      \n      console.error(\"bowerder:addPackage: package's options must be an object\");\n      return null;\n   }\n   \n   var isAlreadyOk = false;\n\n   /* check if package to load is already present in the registry.\n    * if it's a dependency, check if it's present in the registry before package of which depends.\n    * if so, nothing will be done, else the adding operation to the registry will be process.\n   */\n   if (bower.package( pkgName )) {\n\n      isAlreadyOk = true;\n\n      // if the package is already fully loaded *in the DOM*, the current associated callback is executed.\n      if (opts.cbi && bower.package( pkgName ).browser.loaded && bower.callbacks[ pkgName ]) {\n\n         bower.callbacks[ pkgName ][opts.cbi]( bower.package( pkgName ).browser.error );\n      }\n\n      if (opts.caller && (bower.packageIndex( opts.caller ) != -1) ) {\n         /* major browsers load and execute script included by another script asynchronously.\n          * the problem here is that, package which have dependencies have to be execute after them.\n          * therefore, for these package, it's primordial to load them synchronously.\n         */\n         bower.package( pkgName ).browser.async = false;\n         bower.package( opts.caller ).browser.async = false;\n\n         if (bower.packageIndex( opts.caller ) < bower.packageIndex( pkgName )) isAlreadyOk = false;\n      }\n   }\n   \n   if (!isAlreadyOk) { // process the adding operation to the registry.\n\n      // log (if isn't already done) the state of local registry if it isn't provided or well defined\n      if (bower.devMode && !(bower.components instanceof Object) && !bower.isRegStated) {\n\n         switch (bower.browser.regState) {\n            case 1:\n               console.warn('bowerder: local registry isn\\'t found, loader will try to import package through Ajax API.');\n               break;\n            case 2:\n               console.warn('bowerder: seems that local registry isn\\'t provided; if so, loader will try to import package through Ajax API.');\n               break;\n            default:\n               console.warn('bowerder: unexpected state of local registry; loader will try to import package through Ajax API.');\n               break;\n         }\n         \n         bower.isRegStated = true ;\n      }\n      \n      bower.loadingCount++;\n      bower.total++;\n\n      if ((bower.components instanceof Object) && bower.components[ pkgName ]) {\n        \n         var pkgConfig = bower.components[ pkgName ];\n         /* for reason due to size some properties in `bower.json` have been deleted with provided local registry (using bowerder on command line).\n          * `name` is one of them, and the reason of it was removed was to avoid duplication since as once can see, package's configuration is accessible with package's name.\n          * this is valable for `bower.components` (local registry), but not for `bower.packagesTree` (particular generated registry), which need that `name` property to be set.\n         */\n         pkgConfig.name = pkgName;\n\n         loadPackageConfig( pkgConfig );\n         \n         if (bower.cdn.usage) {\n            \n            fetchPackage( pkgName, opts.version, function () {\n               \n               checkReadyToImport(); \n            });\n         }\n         else checkReadyToImport();\n      }\n      else {\n\n         if ((bower.components instanceof Object) && !bower.components[ pkgName ]) {\n\n            console.warn(\"bowerder:addPackage: can't found `\"+ pkgName +\"` in project's local registry; will try to import package through Ajax API.\");\n         }\n\n         var pkgConfigURL = bower.dir +'/'+ pkgName +'/bower.json';\n         \n         if (bower.cdn.usage) {\n            \n            fetchPackage( pkgName, opts.version, function (rawgitURL) {\n                \n               if (rawgitURL) pkgConfigURL = rawgitURL + '/bower.json';\n               \n               getPackageConfig( pkgConfigURL );\n            });\n         }\n         else getPackageConfig( pkgConfigURL );\n      }\n      \n      \n      /**\n       * get a simplified version from a given range sementic version (see https://github.com/npm/node-semver)\n       * @param   {string}   semVer a valid range sementic version\n       * @returns {string} simplified version\n       */\n      function simplifySemVer (semVer) {\n         \n         if (semVer) {\n            // delete particular range operator and get a static version\n            if (/^\\D\\d/.test( semVer )) semVer = semVer.substring(1);\n            if (semVer.indexOf(' - ') !== -1) semVer = semVer.split(' - ')[1];\n            semVer = semVer.replace(' ', '');\n            if (/^\\d\\.\\d$/.test( semVer )) semVer += '.0';\n            if (semVer.indexOf('.') === -1) semVer += '.0.0';\n            \n            if (!/^\\d\\.\\d/.test( semVer )) console.warn('bowerder:addPackage: invalid sementic version: '+ semVer);\n         }\n         \n         return semVer;\n      }\n      \n      /**\n       * search package from online bower's registry and parse resulting informations that can help for loading process. \n       * @param {string}   pkgName  the name of a package\n       * @param {string}   pkgVersion  the package's version\n       * @param {function} callback the function to execute after the end of request process. take the resulting rawgit url as argument \n       */\n      function fetchPackage( pkgName, pkgVersion, callback) {\n\n         // @TODO change this hack to get `bower.json`'s package directly from bower's registry (if it's better)\n         // @TODO the package's version or range version will be send to the futur `bowerder api` that will determine the appropiate versoin to load (v0.9.0 or v1.0.0)\n         // @NOTE considering the previous to do, hope this hack will not be necessary with the futur online package's loading implementation from v0.9.0 or v1.0.0\n         bower.xhrGet('https://libraries.io/api/bower/'+ pkgName, true, function (reponse) {\n            \n            if (!reponse.error) {\n\n               var pkgInfos = JSON.parse( reponse.text ); \n               \n               if (pkgInfos instanceof Object) {\n\n                  if (/^https:\\/\\/github.com/i.test( pkgInfos.repository_url )) {\n\n                     pkgVersion = simplifySemVer( pkgVersion ) || pkgInfos.latest_release_number || 'master';\n                     if (/^v/.test( pkgInfos.latest_release_number ) && /^\\d/.test( pkgVersion )) pkgVersion = 'v' + pkgVersion;\n                     // @TODO remove this test hack and only consider the else instruction when jquery's search will result to appropriate repository (https://github.com/jquery/jquery-dist)\n                     if (pkgName === 'jquery') {\n                        bower.cdn.rawgit[ pkgName ] = 'https://cdn.rawgit.com/'+ pkgInfos.repository_url.replace('https://github.com/', '') +'-dist' +'/'+ pkgVersion;\n                     }\n                     else bower.cdn.rawgit[ pkgName ] = 'https://cdn.rawgit.com/'+ pkgInfos.repository_url.replace('https://github.com/', '') +'/'+ pkgVersion;\n                  }\n                  else console.warn('bowerder:addPackage: can\\'t yet able to load `'+ pkgName +'` from '+ pkgInfos[i].repository_url +' repository.' );\n               }\n               else console.warn('bowerder:addPackage: invalid loaded meta-data of `'+ pkgName +'`.' );\n            }\n            else console.error('bowerder:addPackage: unable to find `'+ pkgName +'` from online registry.' );  \n            \n            if (callback) callback( bower.cdn.rawgit[ pkgName ] );\n         });\n      }\n      \n      /**\n       * locally get and parse a `bower.json` config file of a package\n       * @param {string} jsonURL url where to get the `bower.json` of a package\n       */\n      function getPackageConfig (jsonURL) {\n         \n         bower.xhrGet( jsonURL, true, function (reponse) {\n\n            if (reponse.error) {\n\n               console.error('bowerder:addPackage: unable to load `'+ pkgName +'` component.' );\n\n               /* considering that the package will not be imported and\n                * then will not be added to the packages's configuration registry,\n                * associated callback functions are executed with error from bowerder.\n               */\n               if ((typeof opts.cbi === 'number' || opts.cbi instanceof Number) && bower.callbacks[ pkgName ]) {\n\n                  bower.callbacks[ pkgName ][opts.cbi]( {occured: true, from: 'bowerder'} );\n               } \n\n               bower.browser.error.occured = true;\n               bower.browser.error.fromBowerder.push( pkgName );                \n            }\n            else {\n\n               var pkgConfig = JSON.parse( reponse.text ); \n\n               if (pkgConfig instanceof Object) {\n\n                  delete pkgConfig['ignore'];\n                  delete pkgConfig['keywords'];\n                  delete pkgConfig['moduleType'];\n                  delete pkgConfig['resolutions'];\n\n                  loadPackageConfig( pkgConfig );\n               }\n               else {\n\n                  console.warn('bowerder:addPackage: unable to load `'+ pkgName +'` component.' );\n               }\n            } \n\n            checkReadyToImport();\n         });\n      }\n\n      /**\n       * register package's configuration with it dependencies (if defined) in the packages's tree registry.\n       * @param {object} pkgConfig package's configuration from it `bower.json`\n       * @private\n      */\n      function loadPackageConfig (pkgConfig) {\n\n         // the loader will always consider package's browser property as an object (so it can perform conversion when necessary)\n         // by default package's browser property can content a path of package's main file for browsers\n         if (typeof pkgConfig.browser === 'string') pkgConfig.browser = {main: [pkgConfig.browser]};\n         // by default package's browser property can content a paths's array of package's main files for browsers\n         if (pkgConfig.browser instanceof Array) pkgConfig.browser = {main: pkgConfig.browser};\n         // alternatively package's browser property be set as object understandable by the loader\n         if (!(pkgConfig.browser instanceof Object)) pkgConfig.browser = {};\n         // by default,load and execute script asynchronously\n         pkgConfig.browser.async = true;\n         // by default, files to load from the package aren't yet imported\n         pkgConfig.browser.loaded = false;\n         // by default, set importation status to done without error  \n         pkgConfig.browser.error = {occured: false, from: undefined};\n         // init the number of imported file counter for the package\n         pkgConfig.browser.counter = 0;\n\n         /* minification is a way for developer to have for some files a better loading optimization. \n          * however, `bower.json` spec do not allow to use minified files as mains files for a component.\n          * developers use to set associated `main` property with sources or developments files.\n          * considering how web projects are now build, that pratice isn't advantageous for browsers.\n          * indeed, set an `index.scss` or an unminified `index.js` files *(depending of size)* as main file isn't good for browsers to digest.\n          * that why is now recommended to also set a `browser: []` properties for mains files that browsers can easly digest.\n          * minified files with sourcemaps are specialy welcome in that case.\n          * bowerder will use that properties to load component *in the DOM*; if they aren't set, it will use the `main` property. \n          * here is an example illustration for bowerder to well do it job:\n          * // bower.json\n          *    main: [\"dist/index.scss\", \"dist/index.coffee\"], // keep bower json spec\n          *    browser: [\"dist/index.min.css\", \"dist/index.min.js\"] // for browsers through bowerder\n          *    ... // others properties\n         */\n         if (!pkgConfig.browser.main) {\n\n            if (!pkgConfig.main) {\n\n               console.warn(\"bowerder:addPackage: there isn't main files indication for \"+ pkgName);\n               pkgConfig.main = [];\n            }\n            else pkgConfig.browser.main = (typeof pkgConfig.main === 'string') ? [pkgConfig.main] : pkgConfig.main;\n         }\n         \n         // exclude developer package's target files to importation process\n         if (opts.ignore) {\n            \n            opts.ignore.forEach( function (target) {\n               \n               if (target.indexOf('*') !== -1) {\n                  \n                  target = new RegExp('^'+ target.replace('*', '.+') +'$');\n                  console.log(target);\n                  pkgConfig.browser.main = pkgConfig.browser.main.filter( function (file) { return !target.test( file ); });\n               }\n               else pkgConfig.browser.main = pkgConfig.browser.main.filter( function (file) { return target !== file; });\n            });\n         }\n         \n         // include developer package's target files to importation process\n         if (opts.include) pkgConfig.browser.main = pkgConfig.browser.main.concat( opts.include );\n\n         /* if `opts.caller` is set, then current loading package adress by `pkgName` is a dependency.\n          * therefore, it have to be added before the `opts.caller` in the packages's configuration registry.\n          * else it's just a package to add in the considered registry.\n         */\n         if (opts.caller) {\n\n            // mark package to be synchronously loaded and executed\n            pkgConfig.browser.async = false;\n            bower.package( opts.caller ).browser.async = false;\n\n            if (bower.packageIndex( opts.caller ) != -1) {\n\n               bower.packagesTree.splice( bower.packageIndex( opts.caller ), 0, pkgConfig);\n            }\n         }\n         else {\n\n            bower.packagesTree.push( pkgConfig );\n         }\n\n         // if the current loading package have dependencies, then also process their loading\n         if (pkgConfig['dependencies']) {\n\n            var pkgDeps = Object.getOwnPropertyNames( pkgConfig['dependencies'] );\n\n            pkgDeps.forEach( function (depName) {\n\n               bower.addPackage( depName, {caller: pkgConfig['name'], version: pkgConfig['dependencies'][depName]});\n            });\n         }\n      }\n\n      /**\n       * make sure that loadings packages's configuration process are ok with good dependencies organization,\n       * and proceed to packages importation *in the DOM* with correct order and associated behavior (callback, ...).\n       * @private\n      */\n      function checkReadyToImport() {\n\n         bower.loadingCount--;\n\n         // when all the loading package process are finished, process their importation on the DOM.\n         if (bower.loadingCount === 0) {\n\n            /* if all loading package's configuration process have failed, \n             * directly run globals callbacks (if they are).\n             * this, considering the fact that error can be check from callback by using the `error` argument.\n            */\n            if (bower.packagesTree.length === 0) {\n\n               bower.browser.loaded = true;\n               bower.ready();\n            }\n            else {\n\n               // be sure to have unique package occurence in package's tree\n               for (var i=0; i < bower.packagesTree.length; i++) {\n\n                  for (var j=i+1; j < bower.packagesTree.length; j++) {\n\n                     if (bower.packagesTree[i].name === bower.packagesTree[j].name) {\n\n                        bower.packagesTree.splice( j, 1);\n                        bower.total--;\n\n                        j--;\n                     }\n                  }\n               }\n\n               var pkgScriptTags = [],\n                   pkgLinkTags = [],\n                   isAlreadyLoaded = false,\n                   // Oh the tragedy, detecting opera. See the usage of isOpera for reason.\n                   isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',\n                   loaderTag = undefined,\n                   domLoaderTags = undefined,\n                   devLinkTag = undefined,   // first custom link tag include by developer *in the document's <head>*\n                   devScriptTag = undefined, // first custom Script tag include by developer *in the document's <head>*\n                   getTag = undefined;       // supported tag\n\n               bower.packagesTree.forEach( function (pkg) {\n\n                  isAlreadyLoaded = false;\n                  /* before include a loader tag in the DOM, it's primordial to check if the associated file isn't already loaded in.\n                   * this assure to have an unique instance of a package in the DOM include by our `bower loader`.\n                  */\n                  if (document.querySelector) {\n                     // efficient : this is for all major browsers and IE>8\n                     if (document.head.querySelector('[data-bowerpkg =\"'+pkg.name+'\"]')) isAlreadyLoaded = true;\n                  }\n                  else { // alternative with more hack : this is specialy for IE<=8\n\n                     domLoaderTags = [].slice.call( document.head.getElementsByTagName('link') );\n                     domLoaderTags = domLoaderTags.concat( [].slice.call( document.head.getElementsByTagName('scrpit') ) );\n                     for (var j=0; j < domLoaderTags.length; j++) {\n\n                        if (domLoaderTags[j].getAttribute('data-bowerpkg') === pkg.name ) {\n\n                           isAlreadyLoaded = true;\n                           break;\n                        }\n                     }\n                  }\n\n                  if (!isAlreadyLoaded) {\n\n                     for (index in pkg.browser.main) {\n\n                        getTag = bower.parseTagType( pkg.browser.main[ index ] );\n\n                        if (getTag.name === 'script') { \n\n                           loaderTag = document.createElement('script');\n                           loaderTag.setAttribute('data-bowerpkg', pkg.name);\n                           loaderTag.type = getTag.type;\n                           loaderTag.async = pkg.browser.async;\n\n                           /* with time, for other script support, paid attention to `load` event issue for some file by browsers.\n                            * look at comments below for `link` tag hack for more details.\n                           */\n                           bower.attachPackageCB( loaderTag, pkg.name );\n\n                           if (bower.cdn.usage && bower.cdn.rawgit[ pkg.name ]) {\n                              \n                              loaderTag.src = bower.cdn.rawgit[ pkg.name ] +'/'+ pkg.browser.main[ index ];\n                           }\n                           else loaderTag.src = bower.dir +'/'+ pkg.name +'/'+ pkg.browser.main[ index ];\n\n                           pkgScriptTags.push( loaderTag );\n                        }\n                        if (getTag.name === 'link') {\n\n                           loaderTag = document.createElement('link');\n                           loaderTag.setAttribute('data-bowerpkg', pkg.name);\n                           loaderTag.rel = getTag.rel;\n                           loaderTag.type = getTag.type;\n\n                           /* browsers (as tested on firefox and chrome) seems to not execute event listeners \n                            * attached to `load` envent of some file (exception for css).\n                            * unless will find hack to resolve that, callbacks assignement will be directly checked\n                            * before considered files will have their path set to be included to the DOM.\n                           */\n                           if (getTag.fext !== \"css\") {\n\n                              if (bower.devMode) console.warn(\"bowerder: can't attach callback to `onload` event of \"+ pkg.name +\"/\"+ pkg.browser.main[ index ]);\n                              bower.checkCallback( pkg.name );\n                           }\n                           else bower.attachPackageCB( loaderTag, pkg.name );\n\n                           if (bower.cdn.usage && bower.cdn.rawgit[ pkg.name ]) {\n\n                              loaderTag.href = bower.cdn.rawgit[ pkg.name ] +'/'+ pkg.browser.main[ index ];\n                           }\n                           else loaderTag.href = bower.dir +'/'+ pkg.name +'/'+ pkg.browser.main[ index ];\n\n                           pkgLinkTags.push( loaderTag );\n                        }  \n                        if (getTag.name === 'unknow') {\n\n                           // console.warn('bowerder: unable to load unsupported file: '+ bower.dir +'/'+ pkg.name +'/'+ pkg.browser.main[ index ]);\n                           // count the file for loading's fetching state \n                           bower.package( pkg.name ).browser.counter++;\n                        }                       \n                     }\n                  }\n               });\n\n               /* generally, developer use to include custom stylesheets or scripts,\n                * to overwrite library's properties or functions.\n                * this is done by including library first, before that custom hacks.\n                * therefore bowerder have to do the same to maintain that habit.\n                * loader can identify it imported packages with the `data-bowerpkg` attribute.\n                * it just to make sure to import them before non `data-bowerpkg` considered tag *in document <head>*.\n               */ \n               domLoaderTags = document.head.getElementsByTagName('link');\n               for (var i=0; i < domLoaderTags.length; i++) {\n\n                  if (!domLoaderTags[i].getAttribute('data-bowerpkg') && domLoaderTags[i].rel && (domLoaderTags[i].rel !== 'icon')) {\n\n                     devLinkTag = domLoaderTags[i];\n                     break;\n                  }\n               }\n               domLoaderTags = document.head.getElementsByTagName('script');\n               for (var i=0; i < domLoaderTags.length; i++) {\n\n                  if (!domLoaderTags[i].getAttribute('data-bowerpkg')) {\n\n                     devScriptTag = domLoaderTags[i];\n                     break;\n                  }\n               }\n\n               // Link tags importation process \"in the DOM\"\n               if (devLinkTag) {\n\n                  pkgLinkTags.forEach( function (loaderTag) {\n\n                     document.head.insertBefore( loaderTag, devLinkTag );\n                  });\n               }\n               else {\n\n                  pkgLinkTags.forEach( function (loaderTag) {\n\n                     document.head.appendChild( loaderTag );\n                  });\n               }\n\n               // Script tags importation process \"in the DOM\"\n               if (devScriptTag) {\n\n                  pkgScriptTags.forEach( function (loaderTag) {\n\n                     document.head.insertBefore( loaderTag, devScriptTag );\n                  });\n               }\n               else {\n\n                  pkgScriptTags.forEach( function (loaderTag) {\n\n                     document.head.appendChild( loaderTag );\n                  });\n               }\n\n               if (bower.devMode) console.log( bower.packagesTree );\n            }\n         }\n      }\n   }\n};\n\n\n/**\n * import packages \"in the DOM\" with their dependecies \n * @param   {string}   pkgQuery  package's name (with a specified version, ex: name#1.0.0)\n * @param   {function || object} options callback function to run after full package's importation\n *                                       or an object with these properties:\n *                                       `callback`: function to run,\n *                                        `include`: an array of extra package's files to also load, \n *                                         `ignore`: an array of package's files to exclude and not load \n*/\nbower.import = function (pkgQuery, options) {\n\n   if (typeof pkgQuery !== 'string' && !(pkgQuery instanceof String)) {\n\n      console.error('bowerder:import: first argument must be a string' );\n      return null;\n   }\n   \n   // a query can be the package's name with or without a specified version (ex: name#1.0.0) \n   pkgQuery = pkgQuery.split('#');\n   var pkgq = {name: pkgQuery[0], version: pkgQuery[1]};\n   // given query is normaly a string so re-formatting is welcome after above manipulations\n   pkgQuery = pkgQuery.join('#');\n   \n   var callback = undefined;\n   var cbIndex = undefined; // callback index\n   var fileOpts = {include: [], ignore: []};\n\n   if (options) {\n      \n      if (typeof options === 'function' || options instanceof Function) {\n         \n         callback = options;\n      }\n      else if (options instanceof Object) {\n         \n         if (typeof options.callback === 'function') callback = options.callback; else if(options.callback) console.error('bowerder:import('+ pkgq.name +'): `callback` must be a function');\n         if (options.include instanceof Array) fileOpts.include = options.include; else if(options.include) console.error('bowerder:import('+ pkgq.name +'): `include` must be an array');\n         if (options.ignore instanceof Array) fileOpts.ignore = options.ignore; else if(options.ignore) console.error('bowerder:import('+ pkgq.name +'): `ignore` must be an array');\n      }\n      else console.error('bowerder:import: second argument must be a function or an object');\n   }\n\n   if (callback) {\n\n      if (!bower.callbacks[ pkgq.name ]) bower.callbacks[ pkgq.name ] = [];\n\n      bower.callbacks[ pkgq.name ].push( callback );\n\n      /* with current import's process, callback which is added to the callbacks's registry have the last index.\n       * that index is keeped and will be use to access to that callback if necessary in certains conditions.\n      */\n      cbIndex = bower.callbacks[ pkgq.name ].length - 1;\n   }\n   \n   // loader will be able to import package when the bower components's local registry state will be determinated.\n   if (!(bower.components instanceof Object) && bower.components !== null) {\n\n      bower.browser.waitingImport.push( {name: pkgq.name, version: pkgq.version, include: fileOpts.include, ignore: fileOpts.ignore, cbi: cbIndex} );\n   }\n   else bower.addPackage( pkgq.name, {version: pkgq.version, include: fileOpts.include, ignore: fileOpts.ignore, cbi: cbIndex} );\n};\n\n\n/* first execution zone\n------------------------*/\n/* developer can manually include the bower components's local registry *in the DOM*.\n * if not, the bowerder have to try to include it by itself for better performence for loading process.\n*/\nif (bower.components === undefined) {\n   /* loader script have to be include *in the DOM* with the `data-bowerreg` attribute setting.\n    * that attribute will help to know which tag have to be use to automate local packages's registry loading.\n   */\n   if (document.querySelector) {\n      // efficient : this is for all major browsers and IE>8\n      bower.browser.loaderTag = document.querySelector('script[data-bowerreg]');\n   }\n   else { // alternative with more hack : this is specialy for IE<=8\n\n      var domScriptTags = document.getElementsByTagName('scrpit');\n\n      for (var j=0; j < domScriptTags.length; j++) {\n\n         if (domScriptTags[j].getAttribute('data-bowerreg')) {\n\n            bower.browser.loaderTag = domScriptTags[j];\n            break;\n         }\n      }\n   }\n\n   if (bower.browser.loaderTag) {\n\n      // assuming that loader path will usually be `path-to-bowerdir/bowerder/dist/loader.js`\n      bower.dir = bower.browser.loaderTag.src;\n      for (var i=0; i<3; i++) bower.dir = bower.dir.slice(0, bower.dir.lastIndexOf('/') );\n\n      bower.browser.regTag = document.createElement('script');\n      bower.browser.regTag.onload = function () {\n\n         if (!(bower.components instanceof Object)) {\n\n            bower.components = null; // will allow not already run import's function call to skip waiting import step\n            bower.browser.regState = 1; // local registry isn't found, maybe is provided but isn't well defined\n         }\n\n         bower.browser.waitingImport.forEach( function (pkgInfo) {\n\n            bower.addPackage( pkgInfo.name, {version:  pkgInfo.version, include: pkgInfo.include, ignore: pkgInfo.ignore, cbi: pkgInfo.cbi} );\n         });\n         bower.browser.waitingImport = [];\n      };\n      bower.browser.regTag.onreadystatechange = bower.browser.regTag.onerror = bower.browser.regTag.onload;\n\n      bower.browser.regTag.setAttribute('data-bowerpkg', '#bowerder');\n      bower.browser.regTag.src = bower.dir +'/bowerreg.js';\n\n      document.head.appendChild( bower.browser.regTag );\n   }\n   else {\n\n      bower.components = null; // will allow not already run import's function call to skip waiting import step\n      bower.browser.regState = 2; // local registry isn't provided\n   }\n}"],"sourceRoot":"/source/"}